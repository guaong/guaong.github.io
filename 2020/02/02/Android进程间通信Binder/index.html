<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="前言：笔记根据《深入理解android内核设计思想》记录

大致类似TCP/IP网络,如图:


1 Binder驱动任务
Binder驱动主要做三件事:
1.1 binder_open()
binder_open()的工作是打开/dev/binder节点,生成一个proc对象,初始化后的proc加"/>
    

    <!--Author-->
    
        <meta name="author" content="Guaong"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Android进程间通信Binder"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="前言：笔记根据《深入理解android内核设计思想》记录

大致类似TCP/IP网络,如图:


1 Binder驱动任务
Binder驱动主要做三件事:
1.1 binder_open()
binder_open()的工作是打开/dev/binder节点,生成一个proc对象,初始化后的proc加"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="Guaong"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="http://guaong.github.io/guaong.github.iohttps://i.loli.net/2020/02/07/WyfPYiuTQZneb5N.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="http://guaong.github.io/guaong.github.iohttps://i.loli.net/2020/02/07/WyfPYiuTQZneb5N.jpg"/>
    

    <!-- Title -->
    
    <title>Android进程间通信Binder - Guaong</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/guaong.github.io/css/style.css">


    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet"/>

    <!-- Google Analytics -->
    


    <!-- favicon -->
    

<meta name="generator" content="Hexo 4.2.0"></head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/guaong.github.io/">Configurable Title</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/guaong.github.io/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/guaong.github.io/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/guaong.github.io/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/guaong.github.io/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/guaong" target="_blank" rel="noopener">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('https://i.loli.net/2020/02/07/WyfPYiuTQZneb5N.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Android进程间通信Binder</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2020-02-02
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/guaong.github.io/tags/Android/">#Android</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p>前言：笔记根据《深入理解android内核设计思想》记录<br></p>
<hr>
大致类似TCP/IP网络,如图:

<p><img src="https://guaong.github.io/guaong.github.io/2020/02/02/Android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1Binder/02.png" alt="流程"><br><br></p>
<h1>1 Binder驱动任务</h1><br>
Binder驱动主要做三件事:<br>
<h2>1.1 binder_open()</h2><br>
binder_open()的工作是打开/dev/binder节点,生成一个proc对象,初始化后的proc加入Binder的全局管理中<br>
<h2>1.2 binder_mmap()</h2><br>

<p><img src="https://guaong.github.io/guaong.github.io/2020/02/02/Android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1Binder/01.png" alt="流程"></p>
<h2>1.3 binder_ioctl()</h2><br>
用于向Binder读或写数据,获取Binder版本号等操作

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 代码来自kernel属于驱动内核,与android的源码是分开的 drivers&#x2F;staging&#x2F;android&#x2F;Binder.c *&#x2F; </span><br><span class="line">static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span><br><span class="line">&#123;</span><br><span class="line">    int ret;</span><br><span class="line">    &#x2F;&#x2F; 取出从binder_open()中创建是实例</span><br><span class="line">    struct binder_proc *proc &#x3D; filp-&gt;private_data;</span><br><span class="line">    struct binder_thread *thread;</span><br><span class="line">    unsigned int size &#x3D; _IOC_SIZE(cmd);</span><br><span class="line">    void __user *ubuf &#x3D; (void __user *)arg;</span><br><span class="line"></span><br><span class="line">    &#x2F;*pr_info(&quot;binder_ioctl: %d:%d %x %lx\n&quot;,</span><br><span class="line">            proc-&gt;pid, current-&gt;pid, cmd, arg);*&#x2F;</span><br><span class="line"></span><br><span class="line">    trace_binder_ioctl(cmd, arg);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 阻塞等待执行的结果</span><br><span class="line">    ret &#x3D; wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);</span><br><span class="line">    if (ret)</span><br><span class="line">        goto err_unlocked;</span><br><span class="line"></span><br><span class="line">    binder_lock(__func__);</span><br><span class="line">    thread &#x3D; binder_get_thread(proc);</span><br><span class="line">    if (thread &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        ret &#x3D; -ENOMEM;</span><br><span class="line">        goto err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (cmd) &#123;</span><br><span class="line">    &#x2F;&#x2F; 只看读写这一分支</span><br><span class="line">    case BINDER_WRITE_READ:</span><br><span class="line">        ret &#x3D; binder_ioctl_write_read(filp, cmd, arg, thread);</span><br><span class="line">        if (ret)</span><br><span class="line">            goto err;</span><br><span class="line">        break;</span><br><span class="line">    case BINDER_SET_MAX_THREADS:</span><br><span class="line">        if (copy_from_user(&amp;proc-&gt;max_threads, ubuf, sizeof(proc-&gt;max_threads))) &#123;</span><br><span class="line">            ret &#x3D; -EINVAL;</span><br><span class="line">            goto err;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    case BINDER_SET_CONTEXT_MGR:</span><br><span class="line">        ret &#x3D; binder_ioctl_set_ctx_mgr(filp);</span><br><span class="line">        if (ret)</span><br><span class="line">            goto err;</span><br><span class="line">        ret &#x3D; security_binder_set_context_mgr(proc-&gt;tsk);</span><br><span class="line">        if (ret &lt; 0)</span><br><span class="line">            goto err;</span><br><span class="line">        break;</span><br><span class="line">    case BINDER_THREAD_EXIT:</span><br><span class="line">        binder_debug(BINDER_DEBUG_THREADS, &quot;%d:%d exit\n&quot;,</span><br><span class="line">                 proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">        binder_free_thread(proc, thread);</span><br><span class="line">        thread &#x3D; NULL;</span><br><span class="line">        break;</span><br><span class="line">    case BINDER_VERSION: &#123;</span><br><span class="line">        struct binder_version __user *ver &#x3D; ubuf;</span><br><span class="line"></span><br><span class="line">        if (size !&#x3D; sizeof(struct binder_version)) &#123;</span><br><span class="line">            ret &#x3D; -EINVAL;</span><br><span class="line">            goto err;</span><br><span class="line">        &#125;</span><br><span class="line">        if (put_user(BINDER_CURRENT_PROTOCOL_VERSION,</span><br><span class="line">                 &amp;ver-&gt;protocol_version)) &#123;</span><br><span class="line">            ret &#x3D; -EINVAL;</span><br><span class="line">            goto err;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    default:</span><br><span class="line">        ret &#x3D; -EINVAL;</span><br><span class="line">        goto err;</span><br><span class="line">    &#125;</span><br><span class="line">    ret &#x3D; 0;</span><br><span class="line">err:</span><br><span class="line">    if (thread)</span><br><span class="line">        thread-&gt;looper &amp;&#x3D; ~BINDER_LOOPER_STATE_NEED_RETURN;</span><br><span class="line">    binder_unlock(__func__);</span><br><span class="line">    wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; 2);</span><br><span class="line">    if (ret &amp;&amp; ret !&#x3D; -ERESTARTSYS)</span><br><span class="line">        pr_info(&quot;%d:%d ioctl %x %lx returned %d\n&quot;, proc-&gt;pid, current-&gt;pid, cmd, arg, ret);</span><br><span class="line">err_unlocked:</span><br><span class="line">    trace_binder_ioctl_done(ret);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 代码来自kernel属于驱动内核,与android的源码是分开的 drivers&#x2F;staging&#x2F;android&#x2F;Binder.c *&#x2F; </span><br><span class="line">static int binder_ioctl_write_read(struct file *filp,</span><br><span class="line">                unsigned int cmd, unsigned long arg,</span><br><span class="line">                struct binder_thread *thread)</span><br><span class="line">&#123;</span><br><span class="line">    int ret &#x3D; 0;</span><br><span class="line">    struct binder_proc *proc &#x3D; filp-&gt;private_data;</span><br><span class="line">    unsigned int size &#x3D; _IOC_SIZE(cmd);</span><br><span class="line">    void __user *ubuf &#x3D; (void __user *)arg;</span><br><span class="line">    struct binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">    if (size !&#x3D; sizeof(struct binder_write_read)) &#123;</span><br><span class="line">        ret &#x3D; -EINVAL;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line">    if (copy_from_user(&amp;bwr, ubuf, sizeof(bwr))) &#123; &#x2F;&#x2F;mmap()中提到过,从用户空间copy内容</span><br><span class="line">        ret &#x3D; -EFAULT;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_debug(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">             &quot;%d:%d write %lld at %016llx, read %lld at %016llx\n&quot;,</span><br><span class="line">             proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">             (u64)bwr.write_size, (u64)bwr.write_buffer,</span><br><span class="line">             (u64)bwr.read_size, (u64)bwr.read_buffer);</span><br><span class="line"></span><br><span class="line">    if (bwr.write_size &gt; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; 写操作</span><br><span class="line">        ret &#x3D; binder_thread_write(proc, thread,</span><br><span class="line">                      bwr.write_buffer,</span><br><span class="line">                      bwr.write_size,</span><br><span class="line">                      &amp;bwr.write_consumed);</span><br><span class="line">        trace_binder_write_done(ret);</span><br><span class="line">        if (ret &lt; 0) &#123;</span><br><span class="line">            bwr.read_consumed &#x3D; 0;</span><br><span class="line">            if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr)))</span><br><span class="line">                ret &#x3D; -EFAULT;</span><br><span class="line">            goto out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (bwr.read_size &gt; 0) &#123;</span><br><span class="line">        ret &#x3D; binder_thread_read(proc, thread, bwr.read_buffer,</span><br><span class="line">                     bwr.read_size,</span><br><span class="line">                     &amp;bwr.read_consumed,</span><br><span class="line">                     filp-&gt;f_flags &amp; O_NONBLOCK);</span><br><span class="line">        trace_binder_read_done(ret);</span><br><span class="line">        if (!list_empty(&amp;proc-&gt;todo))</span><br><span class="line">            wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">        if (ret &lt; 0) &#123;</span><br><span class="line">            if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr)))</span><br><span class="line">                ret &#x3D; -EFAULT;</span><br><span class="line">            goto out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_debug(BINDER_DEBUG_READ_WRITE,</span><br><span class="line">             &quot;%d:%d wrote %lld of %lld, read return %lld of %lld\n&quot;,</span><br><span class="line">             proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">             (u64)bwr.write_consumed, (u64)bwr.write_size,</span><br><span class="line">             (u64)bwr.read_consumed, (u64)bwr.read_size);</span><br><span class="line">    if (copy_to_user(ubuf, &amp;bwr, sizeof(bwr))) &#123;</span><br><span class="line">        ret &#x3D; -EFAULT;</span><br><span class="line">        goto out;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以binder_thread_write()为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 代码来自kernel属于驱动内核,与android的源码是分开的 drivers&#x2F;staging&#x2F;android&#x2F;Binder.c *&#x2F; </span><br><span class="line">static int binder_thread_write(struct binder_proc *proc,</span><br><span class="line">            struct binder_thread *thread,</span><br><span class="line">            binder_uintptr_t binder_buffer, size_t size,</span><br><span class="line">            binder_size_t *consumed)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t cmd;</span><br><span class="line">    void __user *buffer &#x3D; (void __user *)(uintptr_t)binder_buffer;</span><br><span class="line">    void __user *ptr &#x3D; buffer + *consumed;</span><br><span class="line">    void __user *end &#x3D; buffer + size;</span><br><span class="line"></span><br><span class="line">    while (ptr &lt; end &amp;&amp; thread-&gt;return_error &#x3D;&#x3D; BR_OK) &#123;</span><br><span class="line">        if (get_user(cmd, (uint32_t __user *)ptr))</span><br><span class="line">            return -EFAULT;</span><br><span class="line">        ptr +&#x3D; sizeof(uint32_t);</span><br><span class="line">        trace_binder_command(cmd);</span><br><span class="line">        if (_IOC_NR(cmd) &lt; ARRAY_SIZE(binder_stats.bc)) &#123;</span><br><span class="line">            binder_stats.bc[_IOC_NR(cmd)]++;</span><br><span class="line">            proc-&gt;stats.bc[_IOC_NR(cmd)]++;</span><br><span class="line">            thread-&gt;stats.bc[_IOC_NR(cmd)]++;</span><br><span class="line">        &#125;</span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">        case BC_INCREFS:</span><br><span class="line">        case BC_ACQUIRE:</span><br><span class="line">        case BC_RELEASE:</span><br><span class="line">        case BC_DECREFS: &#123;</span><br><span class="line">            uint32_t target;</span><br><span class="line">            struct binder_ref *ref;</span><br><span class="line">            const char *debug_string;</span><br><span class="line"></span><br><span class="line">            if (get_user(target, (uint32_t __user *)ptr))</span><br><span class="line">                return -EFAULT;</span><br><span class="line">            ptr +&#x3D; sizeof(uint32_t);</span><br><span class="line">            if (target &#x3D;&#x3D; 0 &amp;&amp; binder_context_mgr_node &amp;&amp;</span><br><span class="line">                (cmd &#x3D;&#x3D; BC_INCREFS || cmd &#x3D;&#x3D; BC_ACQUIRE)) &#123;</span><br><span class="line">                ref &#x3D; binder_get_ref_for_node(proc,</span><br><span class="line">                           binder_context_mgr_node);</span><br><span class="line">                if (ref-&gt;desc !&#x3D; target) &#123;</span><br><span class="line">                    binder_user_error(&quot;%d:%d tried to acquire reference to desc 0, got %d instead\n&quot;,</span><br><span class="line">                        proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">                        ref-&gt;desc);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else</span><br><span class="line">                ref &#x3D; binder_get_ref(proc, target);</span><br><span class="line">            if (ref &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                binder_user_error(&quot;%d:%d refcount change on invalid ref %d\n&quot;,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid, target);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            switch (cmd) &#123;</span><br><span class="line">            case BC_INCREFS:</span><br><span class="line">                debug_string &#x3D; &quot;IncRefs&quot;;</span><br><span class="line">                binder_inc_ref(ref, 0, NULL);</span><br><span class="line">                break;</span><br><span class="line">            case BC_ACQUIRE:</span><br><span class="line">                debug_string &#x3D; &quot;Acquire&quot;;</span><br><span class="line">                binder_inc_ref(ref, 1, NULL);</span><br><span class="line">                break;</span><br><span class="line">            case BC_RELEASE:</span><br><span class="line">                debug_string &#x3D; &quot;Release&quot;;</span><br><span class="line">                binder_dec_ref(ref, 1);</span><br><span class="line">                break;</span><br><span class="line">            case BC_DECREFS:</span><br><span class="line">            default:</span><br><span class="line">                debug_string &#x3D; &quot;DecRefs&quot;;</span><br><span class="line">                binder_dec_ref(ref, 0);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_debug(BINDER_DEBUG_USER_REFS,</span><br><span class="line">                     &quot;%d:%d %s ref %d desc %d s %d w %d for node %d\n&quot;,</span><br><span class="line">                     proc-&gt;pid, thread-&gt;pid, debug_string, ref-&gt;debug_id,</span><br><span class="line">                     ref-&gt;desc, ref-&gt;strong, ref-&gt;weak, ref-&gt;node-&gt;debug_id);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case BC_INCREFS_DONE:</span><br><span class="line">        case BC_ACQUIRE_DONE: &#123;</span><br><span class="line">            binder_uintptr_t node_ptr;</span><br><span class="line">            binder_uintptr_t cookie;</span><br><span class="line">            struct binder_node *node;</span><br><span class="line"></span><br><span class="line">            if (get_user(node_ptr, (binder_uintptr_t __user *)ptr))</span><br><span class="line">                return -EFAULT;</span><br><span class="line">            ptr +&#x3D; sizeof(binder_uintptr_t);</span><br><span class="line">            if (get_user(cookie, (binder_uintptr_t __user *)ptr))</span><br><span class="line">                return -EFAULT;</span><br><span class="line">            ptr +&#x3D; sizeof(binder_uintptr_t);</span><br><span class="line">            node &#x3D; binder_get_node(proc, node_ptr);</span><br><span class="line">            if (node &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                binder_user_error(&quot;%d:%d %s u%016llx no match\n&quot;,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">                    cmd &#x3D;&#x3D; BC_INCREFS_DONE ?</span><br><span class="line">                    &quot;BC_INCREFS_DONE&quot; :</span><br><span class="line">                    &quot;BC_ACQUIRE_DONE&quot;,</span><br><span class="line">                    (u64)node_ptr);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (cookie !&#x3D; node-&gt;cookie) &#123;</span><br><span class="line">                binder_user_error(&quot;%d:%d %s u%016llx node %d cookie mismatch %016llx !&#x3D; %016llx\n&quot;,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">                    cmd &#x3D;&#x3D; BC_INCREFS_DONE ?</span><br><span class="line">                    &quot;BC_INCREFS_DONE&quot; : &quot;BC_ACQUIRE_DONE&quot;,</span><br><span class="line">                    (u64)node_ptr, node-&gt;debug_id,</span><br><span class="line">                    (u64)cookie, (u64)node-&gt;cookie);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (cmd &#x3D;&#x3D; BC_ACQUIRE_DONE) &#123;</span><br><span class="line">                if (node-&gt;pending_strong_ref &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    binder_user_error(&quot;%d:%d BC_ACQUIRE_DONE node %d has no pending acquire request\n&quot;,</span><br><span class="line">                        proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">                        node-&gt;debug_id);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;pending_strong_ref &#x3D; 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (node-&gt;pending_weak_ref &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    binder_user_error(&quot;%d:%d BC_INCREFS_DONE node %d has no pending increfs request\n&quot;,</span><br><span class="line">                        proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">                        node-&gt;debug_id);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;pending_weak_ref &#x3D; 0;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dec_node(node, cmd &#x3D;&#x3D; BC_ACQUIRE_DONE, 0);</span><br><span class="line">            binder_debug(BINDER_DEBUG_USER_REFS,</span><br><span class="line">                     &quot;%d:%d %s node %d ls %d lw %d\n&quot;,</span><br><span class="line">                     proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">                     cmd &#x3D;&#x3D; BC_INCREFS_DONE ? &quot;BC_INCREFS_DONE&quot; : &quot;BC_ACQUIRE_DONE&quot;,</span><br><span class="line">                     node-&gt;debug_id, node-&gt;local_strong_refs, node-&gt;local_weak_refs);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case BC_ATTEMPT_ACQUIRE:</span><br><span class="line">            pr_err(&quot;BC_ATTEMPT_ACQUIRE not supported\n&quot;);</span><br><span class="line">            return -EINVAL;</span><br><span class="line">        case BC_ACQUIRE_RESULT:</span><br><span class="line">            pr_err(&quot;BC_ACQUIRE_RESULT not supported\n&quot;);</span><br><span class="line">            return -EINVAL;</span><br><span class="line"></span><br><span class="line">        case BC_FREE_BUFFER: &#123;</span><br><span class="line">            binder_uintptr_t data_ptr;</span><br><span class="line">            struct binder_buffer *buffer;</span><br><span class="line"></span><br><span class="line">            if (get_user(data_ptr, (binder_uintptr_t __user *)ptr))</span><br><span class="line">                return -EFAULT;</span><br><span class="line">            ptr +&#x3D; sizeof(binder_uintptr_t);</span><br><span class="line"></span><br><span class="line">            buffer &#x3D; binder_buffer_lookup(proc, data_ptr);</span><br><span class="line">            if (buffer &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                binder_user_error(&quot;%d:%d BC_FREE_BUFFER u%016llx no match\n&quot;,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid, (u64)data_ptr);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!buffer-&gt;allow_user_free) &#123;</span><br><span class="line">                binder_user_error(&quot;%d:%d BC_FREE_BUFFER u%016llx matched unreturned buffer\n&quot;,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid, (u64)data_ptr);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_debug(BINDER_DEBUG_FREE_BUFFER,</span><br><span class="line">                     &quot;%d:%d BC_FREE_BUFFER u%016llx found buffer %d for %s transaction\n&quot;,</span><br><span class="line">                     proc-&gt;pid, thread-&gt;pid, (u64)data_ptr,</span><br><span class="line">                     buffer-&gt;debug_id,</span><br><span class="line">                     buffer-&gt;transaction ? &quot;active&quot; : &quot;finished&quot;);</span><br><span class="line"></span><br><span class="line">            if (buffer-&gt;transaction) &#123;</span><br><span class="line">                buffer-&gt;transaction-&gt;buffer &#x3D; NULL;</span><br><span class="line">                buffer-&gt;transaction &#x3D; NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            if (buffer-&gt;async_transaction &amp;&amp; buffer-&gt;target_node) &#123;</span><br><span class="line">                BUG_ON(!buffer-&gt;target_node-&gt;has_async_transaction);</span><br><span class="line">                if (list_empty(&amp;buffer-&gt;target_node-&gt;async_todo))</span><br><span class="line">                    buffer-&gt;target_node-&gt;has_async_transaction &#x3D; 0;</span><br><span class="line">                else</span><br><span class="line">                    list_move_tail(buffer-&gt;target_node-&gt;async_todo.next, &amp;thread-&gt;todo);</span><br><span class="line">            &#125;</span><br><span class="line">            trace_binder_transaction_buffer_release(buffer);</span><br><span class="line">            binder_transaction_buffer_release(proc, buffer, NULL);</span><br><span class="line">            binder_free_buf(proc, buffer);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 根据我们从getSerive()开始,这里的cmd就是BC_TRANSACTION</span><br><span class="line">        case BC_TRANSACTION:</span><br><span class="line">        case BC_REPLY: &#123;</span><br><span class="line">            struct binder_transaction_data tr;</span><br><span class="line"></span><br><span class="line">            if (copy_from_user(&amp;tr, ptr, sizeof(tr)))</span><br><span class="line">                return -EFAULT;</span><br><span class="line">            ptr +&#x3D; sizeof(tr);</span><br><span class="line">            binder_transaction(proc, thread, &amp;tr, cmd &#x3D;&#x3D; BC_REPLY);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        case BC_REGISTER_LOOPER:</span><br><span class="line">            binder_debug(BINDER_DEBUG_THREADS,</span><br><span class="line">                     &quot;%d:%d BC_REGISTER_LOOPER\n&quot;,</span><br><span class="line">                     proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">            if (thread-&gt;looper &amp; BINDER_LOOPER_STATE_ENTERED) &#123;</span><br><span class="line">                thread-&gt;looper |&#x3D; BINDER_LOOPER_STATE_INVALID;</span><br><span class="line">                binder_user_error(&quot;%d:%d ERROR: BC_REGISTER_LOOPER called after BC_ENTER_LOOPER\n&quot;,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">            &#125; else if (proc-&gt;requested_threads &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                thread-&gt;looper |&#x3D; BINDER_LOOPER_STATE_INVALID;</span><br><span class="line">                binder_user_error(&quot;%d:%d ERROR: BC_REGISTER_LOOPER called without request\n&quot;,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                proc-&gt;requested_threads--;</span><br><span class="line">                proc-&gt;requested_threads_started++;</span><br><span class="line">            &#125;</span><br><span class="line">            thread-&gt;looper |&#x3D; BINDER_LOOPER_STATE_REGISTERED;</span><br><span class="line">            break;</span><br><span class="line">        case BC_ENTER_LOOPER:</span><br><span class="line">            binder_debug(BINDER_DEBUG_THREADS,</span><br><span class="line">                     &quot;%d:%d BC_ENTER_LOOPER\n&quot;,</span><br><span class="line">                     proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">            if (thread-&gt;looper &amp; BINDER_LOOPER_STATE_REGISTERED) &#123;</span><br><span class="line">                thread-&gt;looper |&#x3D; BINDER_LOOPER_STATE_INVALID;</span><br><span class="line">                binder_user_error(&quot;%d:%d ERROR: BC_ENTER_LOOPER called after BC_REGISTER_LOOPER\n&quot;,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">            &#125;</span><br><span class="line">            thread-&gt;looper |&#x3D; BINDER_LOOPER_STATE_ENTERED;</span><br><span class="line">            break;</span><br><span class="line">        case BC_EXIT_LOOPER:</span><br><span class="line">            binder_debug(BINDER_DEBUG_THREADS,</span><br><span class="line">                     &quot;%d:%d BC_EXIT_LOOPER\n&quot;,</span><br><span class="line">                     proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">            thread-&gt;looper |&#x3D; BINDER_LOOPER_STATE_EXITED;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case BC_REQUEST_DEATH_NOTIFICATION:</span><br><span class="line">        case BC_CLEAR_DEATH_NOTIFICATION: &#123;</span><br><span class="line">            uint32_t target;</span><br><span class="line">            binder_uintptr_t cookie;</span><br><span class="line">            struct binder_ref *ref;</span><br><span class="line">            struct binder_ref_death *death;</span><br><span class="line"></span><br><span class="line">            if (get_user(target, (uint32_t __user *)ptr))</span><br><span class="line">                return -EFAULT;</span><br><span class="line">            ptr +&#x3D; sizeof(uint32_t);</span><br><span class="line">            if (get_user(cookie, (binder_uintptr_t __user *)ptr))</span><br><span class="line">                return -EFAULT;</span><br><span class="line">            ptr +&#x3D; sizeof(binder_uintptr_t);</span><br><span class="line">            ref &#x3D; binder_get_ref(proc, target);</span><br><span class="line">            if (ref &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                binder_user_error(&quot;%d:%d %s invalid ref %d\n&quot;,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">                    cmd &#x3D;&#x3D; BC_REQUEST_DEATH_NOTIFICATION ?</span><br><span class="line">                    &quot;BC_REQUEST_DEATH_NOTIFICATION&quot; :</span><br><span class="line">                    &quot;BC_CLEAR_DEATH_NOTIFICATION&quot;,</span><br><span class="line">                    target);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            binder_debug(BINDER_DEBUG_DEATH_NOTIFICATION,</span><br><span class="line">                     &quot;%d:%d %s %016llx ref %d desc %d s %d w %d for node %d\n&quot;,</span><br><span class="line">                     proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">                     cmd &#x3D;&#x3D; BC_REQUEST_DEATH_NOTIFICATION ?</span><br><span class="line">                     &quot;BC_REQUEST_DEATH_NOTIFICATION&quot; :</span><br><span class="line">                     &quot;BC_CLEAR_DEATH_NOTIFICATION&quot;,</span><br><span class="line">                     (u64)cookie, ref-&gt;debug_id, ref-&gt;desc,</span><br><span class="line">                     ref-&gt;strong, ref-&gt;weak, ref-&gt;node-&gt;debug_id);</span><br><span class="line"></span><br><span class="line">            if (cmd &#x3D;&#x3D; BC_REQUEST_DEATH_NOTIFICATION) &#123;</span><br><span class="line">                if (ref-&gt;death) &#123;</span><br><span class="line">                    binder_user_error(&quot;%d:%d BC_REQUEST_DEATH_NOTIFICATION death notification already set\n&quot;,</span><br><span class="line">                        proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                death &#x3D; kzalloc(sizeof(*death), GFP_KERNEL);</span><br><span class="line">                if (death &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                    thread-&gt;return_error &#x3D; BR_ERROR;</span><br><span class="line">                    binder_debug(BINDER_DEBUG_FAILED_TRANSACTION,</span><br><span class="line">                             &quot;%d:%d BC_REQUEST_DEATH_NOTIFICATION failed\n&quot;,</span><br><span class="line">                             proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                binder_stats_created(BINDER_STAT_DEATH);</span><br><span class="line">                INIT_LIST_HEAD(&amp;death-&gt;work.entry);</span><br><span class="line">                death-&gt;cookie &#x3D; cookie;</span><br><span class="line">                ref-&gt;death &#x3D; death;</span><br><span class="line">                if (ref-&gt;node-&gt;proc &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                    ref-&gt;death-&gt;work.type &#x3D; BINDER_WORK_DEAD_BINDER;</span><br><span class="line">                    if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123;</span><br><span class="line">                        list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;thread-&gt;todo);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        list_add_tail(&amp;ref-&gt;death-&gt;work.entry, &amp;proc-&gt;todo);</span><br><span class="line">                        wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (ref-&gt;death &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                    binder_user_error(&quot;%d:%d BC_CLEAR_DEATH_NOTIFICATION death notification not active\n&quot;,</span><br><span class="line">                        proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                death &#x3D; ref-&gt;death;</span><br><span class="line">                if (death-&gt;cookie !&#x3D; cookie) &#123;</span><br><span class="line">                    binder_user_error(&quot;%d:%d BC_CLEAR_DEATH_NOTIFICATION death notification cookie mismatch %016llx !&#x3D; %016llx\n&quot;,</span><br><span class="line">                        proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">                        (u64)death-&gt;cookie,</span><br><span class="line">                        (u64)cookie);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                ref-&gt;death &#x3D; NULL;</span><br><span class="line">                if (list_empty(&amp;death-&gt;work.entry)) &#123;</span><br><span class="line">                    death-&gt;work.type &#x3D; BINDER_WORK_CLEAR_DEATH_NOTIFICATION;</span><br><span class="line">                    if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123;</span><br><span class="line">                        list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);</span><br><span class="line">                        wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    BUG_ON(death-&gt;work.type !&#x3D; BINDER_WORK_DEAD_BINDER);</span><br><span class="line">                    death-&gt;work.type &#x3D; BINDER_WORK_DEAD_BINDER_AND_CLEAR;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; break;</span><br><span class="line">        case BC_DEAD_BINDER_DONE: &#123;</span><br><span class="line">            struct binder_work *w;</span><br><span class="line">            binder_uintptr_t cookie;</span><br><span class="line">            struct binder_ref_death *death &#x3D; NULL;</span><br><span class="line"></span><br><span class="line">            if (get_user(cookie, (binder_uintptr_t __user *)ptr))</span><br><span class="line">                return -EFAULT;</span><br><span class="line"></span><br><span class="line">            ptr +&#x3D; sizeof(void *);</span><br><span class="line">            list_for_each_entry(w, &amp;proc-&gt;delivered_death, entry) &#123;</span><br><span class="line">                struct binder_ref_death *tmp_death &#x3D; container_of(w, struct binder_ref_death, work);</span><br><span class="line"></span><br><span class="line">                if (tmp_death-&gt;cookie &#x3D;&#x3D; cookie) &#123;</span><br><span class="line">                    death &#x3D; tmp_death;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_debug(BINDER_DEBUG_DEAD_BINDER,</span><br><span class="line">                     &quot;%d:%d BC_DEAD_BINDER_DONE %016llx found %p\n&quot;,</span><br><span class="line">                     proc-&gt;pid, thread-&gt;pid, (u64)cookie,</span><br><span class="line">                     death);</span><br><span class="line">            if (death &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                binder_user_error(&quot;%d:%d BC_DEAD_BINDER_DONE %016llx not found\n&quot;,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid, (u64)cookie);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list_del_init(&amp;death-&gt;work.entry);</span><br><span class="line">            if (death-&gt;work.type &#x3D;&#x3D; BINDER_WORK_DEAD_BINDER_AND_CLEAR) &#123;</span><br><span class="line">                death-&gt;work.type &#x3D; BINDER_WORK_CLEAR_DEATH_NOTIFICATION;</span><br><span class="line">                if (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED | BINDER_LOOPER_STATE_ENTERED)) &#123;</span><br><span class="line">                    list_add_tail(&amp;death-&gt;work.entry, &amp;thread-&gt;todo);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    list_add_tail(&amp;death-&gt;work.entry, &amp;proc-&gt;todo);</span><br><span class="line">                    wake_up_interruptible(&amp;proc-&gt;wait);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            pr_err(&quot;%d:%d unknown command %d\n&quot;,</span><br><span class="line">                   proc-&gt;pid, thread-&gt;pid, cmd);</span><br><span class="line">            return -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        *consumed &#x3D; ptr - buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* 代码来自kernel属于驱动内核,与android的源码是分开的 drivers&#x2F;staging&#x2F;android&#x2F;Binder.c *&#x2F; </span><br><span class="line">static void binder_transaction(struct binder_proc *proc,</span><br><span class="line">                   struct binder_thread *thread,</span><br><span class="line">                   struct binder_transaction_data *tr, int reply)</span><br><span class="line">&#123;</span><br><span class="line">    struct binder_transaction *t;</span><br><span class="line">    struct binder_work *tcomplete;</span><br><span class="line">    binder_size_t *offp, *off_end;</span><br><span class="line">    binder_size_t off_min;</span><br><span class="line">    struct binder_proc *target_proc;</span><br><span class="line">    struct binder_thread *target_thread &#x3D; NULL;</span><br><span class="line">    struct binder_node *target_node &#x3D; NULL;</span><br><span class="line">    struct list_head *target_list;</span><br><span class="line">    wait_queue_head_t *target_wait;</span><br><span class="line">    struct binder_transaction *in_reply_to &#x3D; NULL;</span><br><span class="line">    struct binder_transaction_log_entry *e;</span><br><span class="line">    uint32_t return_error;</span><br><span class="line"></span><br><span class="line">    e &#x3D; binder_transaction_log_add(&amp;binder_transaction_log);</span><br><span class="line">    e-&gt;call_type &#x3D; reply ? 2 : !!(tr-&gt;flags &amp; TF_ONE_WAY);</span><br><span class="line">    e-&gt;from_proc &#x3D; proc-&gt;pid;</span><br><span class="line">    e-&gt;from_thread &#x3D; thread-&gt;pid;</span><br><span class="line">    e-&gt;target_handle &#x3D; tr-&gt;target.handle;</span><br><span class="line">    e-&gt;data_size &#x3D; tr-&gt;data_size;</span><br><span class="line">    e-&gt;offsets_size &#x3D; tr-&gt;offsets_size;</span><br><span class="line"></span><br><span class="line">    if (reply) &#123;</span><br><span class="line">        in_reply_to &#x3D; thread-&gt;transaction_stack;</span><br><span class="line">        if (in_reply_to &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            binder_user_error(&quot;%d:%d got reply transaction with no transaction stack\n&quot;,</span><br><span class="line">                      proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">            return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">            goto err_empty_call_stack;</span><br><span class="line">        &#125;</span><br><span class="line">        binder_set_nice(in_reply_to-&gt;saved_priority);</span><br><span class="line">        if (in_reply_to-&gt;to_thread !&#x3D; thread) &#123;</span><br><span class="line">            binder_user_error(&quot;%d:%d got reply transaction with bad transaction stack, transaction %d has target %d:%d\n&quot;,</span><br><span class="line">                proc-&gt;pid, thread-&gt;pid, in_reply_to-&gt;debug_id,</span><br><span class="line">                in_reply_to-&gt;to_proc ?</span><br><span class="line">                in_reply_to-&gt;to_proc-&gt;pid : 0,</span><br><span class="line">                in_reply_to-&gt;to_thread ?</span><br><span class="line">                in_reply_to-&gt;to_thread-&gt;pid : 0);</span><br><span class="line">            return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">            in_reply_to &#x3D; NULL;</span><br><span class="line">            goto err_bad_call_stack;</span><br><span class="line">        &#125;</span><br><span class="line">        thread-&gt;transaction_stack &#x3D; in_reply_to-&gt;to_parent;</span><br><span class="line">        target_thread &#x3D; in_reply_to-&gt;from;</span><br><span class="line">        if (target_thread &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            return_error &#x3D; BR_DEAD_REPLY;</span><br><span class="line">            goto err_dead_binder;</span><br><span class="line">        &#125;</span><br><span class="line">        if (target_thread-&gt;transaction_stack !&#x3D; in_reply_to) &#123;</span><br><span class="line">            binder_user_error(&quot;%d:%d got reply transaction with bad target transaction stack %d, expected %d\n&quot;,</span><br><span class="line">                proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">                target_thread-&gt;transaction_stack ?</span><br><span class="line">                target_thread-&gt;transaction_stack-&gt;debug_id : 0,</span><br><span class="line">                in_reply_to-&gt;debug_id);</span><br><span class="line">            return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">            in_reply_to &#x3D; NULL;</span><br><span class="line">            target_thread &#x3D; NULL;</span><br><span class="line">            goto err_dead_binder;</span><br><span class="line">        &#125;</span><br><span class="line">        target_proc &#x3D; target_thread-&gt;proc;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (tr-&gt;target.handle) &#123;</span><br><span class="line">            struct binder_ref *ref;</span><br><span class="line"></span><br><span class="line">            ref &#x3D; binder_get_ref(proc, tr-&gt;target.handle);</span><br><span class="line">            if (ref &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                binder_user_error(&quot;%d:%d got transaction to invalid handle\n&quot;,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">                return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">                goto err_invalid_target_handle;</span><br><span class="line">            &#125;</span><br><span class="line">            target_node &#x3D; ref-&gt;node;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            target_node &#x3D; binder_context_mgr_node;</span><br><span class="line">            if (target_node &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                return_error &#x3D; BR_DEAD_REPLY;</span><br><span class="line">                goto err_no_context_mgr_node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        e-&gt;to_node &#x3D; target_node-&gt;debug_id;</span><br><span class="line">        target_proc &#x3D; target_node-&gt;proc;</span><br><span class="line">        if (target_proc &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            return_error &#x3D; BR_DEAD_REPLY;</span><br><span class="line">            goto err_dead_binder;</span><br><span class="line">        &#125;</span><br><span class="line">        if (security_binder_transaction(proc-&gt;tsk, target_proc-&gt;tsk) &lt; 0) &#123;</span><br><span class="line">            return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">            goto err_invalid_target_handle;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123;</span><br><span class="line">            struct binder_transaction *tmp;</span><br><span class="line"></span><br><span class="line">            tmp &#x3D; thread-&gt;transaction_stack;</span><br><span class="line">            if (tmp-&gt;to_thread !&#x3D; thread) &#123;</span><br><span class="line">                binder_user_error(&quot;%d:%d got new transaction with bad transaction stack, transaction %d has target %d:%d\n&quot;,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid, tmp-&gt;debug_id,</span><br><span class="line">                    tmp-&gt;to_proc ? tmp-&gt;to_proc-&gt;pid : 0,</span><br><span class="line">                    tmp-&gt;to_thread ?</span><br><span class="line">                    tmp-&gt;to_thread-&gt;pid : 0);</span><br><span class="line">                return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">                goto err_bad_call_stack;</span><br><span class="line">            &#125;</span><br><span class="line">            while (tmp) &#123;</span><br><span class="line">                if (tmp-&gt;from &amp;&amp; tmp-&gt;from-&gt;proc &#x3D;&#x3D; target_proc)</span><br><span class="line">                    target_thread &#x3D; tmp-&gt;from;</span><br><span class="line">                tmp &#x3D; tmp-&gt;from_parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (target_thread) &#123;</span><br><span class="line">        e-&gt;to_thread &#x3D; target_thread-&gt;pid;</span><br><span class="line">        target_list &#x3D; &amp;target_thread-&gt;todo;</span><br><span class="line">        target_wait &#x3D; &amp;target_thread-&gt;wait;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        target_list &#x3D; &amp;target_proc-&gt;todo;</span><br><span class="line">        target_wait &#x3D; &amp;target_proc-&gt;wait;</span><br><span class="line">    &#125;</span><br><span class="line">    e-&gt;to_proc &#x3D; target_proc-&gt;pid;</span><br><span class="line"></span><br><span class="line">    &#x2F;* TODO: reuse incoming transaction for reply *&#x2F;</span><br><span class="line">    t &#x3D; kzalloc(sizeof(*t), GFP_KERNEL);</span><br><span class="line">    if (t &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">        goto err_alloc_t_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_stats_created(BINDER_STAT_TRANSACTION);</span><br><span class="line"></span><br><span class="line">    tcomplete &#x3D; kzalloc(sizeof(*tcomplete), GFP_KERNEL);</span><br><span class="line">    if (tcomplete &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">        goto err_alloc_tcomplete_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line"></span><br><span class="line">    t-&gt;debug_id &#x3D; ++binder_last_id;</span><br><span class="line">    e-&gt;debug_id &#x3D; t-&gt;debug_id;</span><br><span class="line"></span><br><span class="line">    if (reply)</span><br><span class="line">        binder_debug(BINDER_DEBUG_TRANSACTION,</span><br><span class="line">                 &quot;%d:%d BC_REPLY %d -&gt; %d:%d, data %016llx-%016llx size %lld-%lld\n&quot;,</span><br><span class="line">                 proc-&gt;pid, thread-&gt;pid, t-&gt;debug_id,</span><br><span class="line">                 target_proc-&gt;pid, target_thread-&gt;pid,</span><br><span class="line">                 (u64)tr-&gt;data.ptr.buffer,</span><br><span class="line">                 (u64)tr-&gt;data.ptr.offsets,</span><br><span class="line">                 (u64)tr-&gt;data_size, (u64)tr-&gt;offsets_size);</span><br><span class="line">    else</span><br><span class="line">        binder_debug(BINDER_DEBUG_TRANSACTION,</span><br><span class="line">                 &quot;%d:%d BC_TRANSACTION %d -&gt; %d - node %d, data %016llx-%016llx size %lld-%lld\n&quot;,</span><br><span class="line">                 proc-&gt;pid, thread-&gt;pid, t-&gt;debug_id,</span><br><span class="line">                 target_proc-&gt;pid, target_node-&gt;debug_id,</span><br><span class="line">                 (u64)tr-&gt;data.ptr.buffer,</span><br><span class="line">                 (u64)tr-&gt;data.ptr.offsets,</span><br><span class="line">                 (u64)tr-&gt;data_size, (u64)tr-&gt;offsets_size);</span><br><span class="line"></span><br><span class="line">    if (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">        t-&gt;from &#x3D; thread;</span><br><span class="line">    else</span><br><span class="line">        t-&gt;from &#x3D; NULL;</span><br><span class="line">    t-&gt;sender_euid &#x3D; task_euid(proc-&gt;tsk);</span><br><span class="line">    t-&gt;to_proc &#x3D; target_proc;</span><br><span class="line">    t-&gt;to_thread &#x3D; target_thread;</span><br><span class="line">    t-&gt;code &#x3D; tr-&gt;code;</span><br><span class="line">    t-&gt;flags &#x3D; tr-&gt;flags;</span><br><span class="line">    t-&gt;priority &#x3D; task_nice(current);</span><br><span class="line"></span><br><span class="line">    trace_binder_transaction(reply, t, target_node);</span><br><span class="line"></span><br><span class="line">    t-&gt;buffer &#x3D; binder_alloc_buf(target_proc, tr-&gt;data_size,</span><br><span class="line">        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">    if (t-&gt;buffer &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">        goto err_binder_alloc_buf_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;buffer-&gt;allow_user_free &#x3D; 0;</span><br><span class="line">    t-&gt;buffer-&gt;debug_id &#x3D; t-&gt;debug_id;</span><br><span class="line">    t-&gt;buffer-&gt;transaction &#x3D; t;</span><br><span class="line">    t-&gt;buffer-&gt;target_node &#x3D; target_node;</span><br><span class="line">    trace_binder_transaction_alloc_buf(t-&gt;buffer);</span><br><span class="line">    if (target_node)</span><br><span class="line">        binder_inc_node(target_node, 1, 0, NULL);</span><br><span class="line"></span><br><span class="line">    offp &#x3D; (binder_size_t *)(t-&gt;buffer-&gt;data +</span><br><span class="line">                 ALIGN(tr-&gt;data_size, sizeof(void *)));</span><br><span class="line"></span><br><span class="line">    if (copy_from_user(t-&gt;buffer-&gt;data, (const void __user *)(uintptr_t)</span><br><span class="line">               tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">        binder_user_error(&quot;%d:%d got transaction with invalid data ptr\n&quot;,</span><br><span class="line">                proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">        return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">        goto err_copy_data_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    if (copy_from_user(offp, (const void __user *)(uintptr_t)</span><br><span class="line">               tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">        binder_user_error(&quot;%d:%d got transaction with invalid offsets ptr\n&quot;,</span><br><span class="line">                proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">        return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">        goto err_copy_data_failed;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!IS_ALIGNED(tr-&gt;offsets_size, sizeof(binder_size_t))) &#123;</span><br><span class="line">        binder_user_error(&quot;%d:%d got transaction with invalid offsets size, %lld\n&quot;,</span><br><span class="line">                proc-&gt;pid, thread-&gt;pid, (u64)tr-&gt;offsets_size);</span><br><span class="line">        return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">        goto err_bad_offset;</span><br><span class="line">    &#125;</span><br><span class="line">    off_end &#x3D; (void *)offp + tr-&gt;offsets_size;</span><br><span class="line">    off_min &#x3D; 0;</span><br><span class="line">    for (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">        struct flat_binder_object *fp;</span><br><span class="line"></span><br><span class="line">        if (*offp &gt; t-&gt;buffer-&gt;data_size - sizeof(*fp) ||</span><br><span class="line">            *offp &lt; off_min ||</span><br><span class="line">            t-&gt;buffer-&gt;data_size &lt; sizeof(*fp) ||</span><br><span class="line">            !IS_ALIGNED(*offp, sizeof(u32))) &#123;</span><br><span class="line">            binder_user_error(&quot;%d:%d got transaction with invalid offset, %lld (min %lld, max %lld)\n&quot;,</span><br><span class="line">                      proc-&gt;pid, thread-&gt;pid, (u64)*offp,</span><br><span class="line">                      (u64)off_min,</span><br><span class="line">                      (u64)(t-&gt;buffer-&gt;data_size -</span><br><span class="line">                      sizeof(*fp)));</span><br><span class="line">            return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">            goto err_bad_offset;</span><br><span class="line">        &#125;</span><br><span class="line">        fp &#x3D; (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">        off_min &#x3D; *offp + sizeof(struct flat_binder_object);</span><br><span class="line">        switch (fp-&gt;type) &#123;</span><br><span class="line">        case BINDER_TYPE_BINDER:</span><br><span class="line">        case BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">            struct binder_ref *ref;</span><br><span class="line">            struct binder_node *node &#x3D; binder_get_node(proc, fp-&gt;binder);</span><br><span class="line"></span><br><span class="line">            if (node &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                node &#x3D; binder_new_node(proc, fp-&gt;binder, fp-&gt;cookie);</span><br><span class="line">                if (node &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                    return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">                    goto err_binder_new_node_failed;</span><br><span class="line">                &#125;</span><br><span class="line">                node-&gt;min_priority &#x3D; fp-&gt;flags &amp; FLAT_BINDER_FLAG_PRIORITY_MASK;</span><br><span class="line">                node-&gt;accept_fds &#x3D; !!(fp-&gt;flags &amp; FLAT_BINDER_FLAG_ACCEPTS_FDS);</span><br><span class="line">            &#125;</span><br><span class="line">            if (fp-&gt;cookie !&#x3D; node-&gt;cookie) &#123;</span><br><span class="line">                binder_user_error(&quot;%d:%d sending u%016llx node %d, cookie mismatch %016llx !&#x3D; %016llx\n&quot;,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">                    (u64)fp-&gt;binder, node-&gt;debug_id,</span><br><span class="line">                    (u64)fp-&gt;cookie, (u64)node-&gt;cookie);</span><br><span class="line">                return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">                goto err_binder_get_ref_for_node_failed;</span><br><span class="line">            &#125;</span><br><span class="line">    if (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) &#123;</span><br><span class="line">                return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">                goto err_binder_get_ref_for_node_failed;</span><br><span class="line">            &#125;</span><br><span class="line">            ref &#x3D; binder_get_ref_for_node(target_proc, node);</span><br><span class="line">            if (ref &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">                goto err_binder_get_ref_for_node_failed;</span><br><span class="line">            &#125;</span><br><span class="line">            if (fp-&gt;type &#x3D;&#x3D; BINDER_TYPE_BINDER)</span><br><span class="line">                fp-&gt;type &#x3D; BINDER_TYPE_HANDLE;</span><br><span class="line">            else</span><br><span class="line">                fp-&gt;type &#x3D; BINDER_TYPE_WEAK_HANDLE;</span><br><span class="line">            fp-&gt;handle &#x3D; ref-&gt;desc;</span><br><span class="line">            binder_inc_ref(ref, fp-&gt;type &#x3D;&#x3D; BINDER_TYPE_HANDLE,</span><br><span class="line">                       &amp;thread-&gt;todo);</span><br><span class="line"></span><br><span class="line">            trace_binder_transaction_node_to_ref(t, node, ref);</span><br><span class="line">            binder_debug(BINDER_DEBUG_TRANSACTION,</span><br><span class="line">                     &quot;        node %d u%016llx -&gt; ref %d desc %d\n&quot;,</span><br><span class="line">                     node-&gt;debug_id, (u64)node-&gt;ptr,</span><br><span class="line">                     ref-&gt;debug_id, ref-&gt;desc);</span><br><span class="line">        &#125; break;</span><br><span class="line">        case BINDER_TYPE_HANDLE:</span><br><span class="line">        case BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">            struct binder_ref *ref &#x3D; binder_get_ref(proc, fp-&gt;handle);</span><br><span class="line"></span><br><span class="line">            if (ref &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                binder_user_error(&quot;%d:%d got transaction with invalid handle, %d\n&quot;,</span><br><span class="line">                        proc-&gt;pid,</span><br><span class="line">                        thread-&gt;pid, fp-&gt;handle);</span><br><span class="line">                return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">                goto err_binder_get_ref_failed;</span><br><span class="line">            &#125;</span><br><span class="line">            if (security_binder_transfer_binder(proc-&gt;tsk, target_proc-&gt;tsk)) &#123;</span><br><span class="line">                return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">                goto err_binder_get_ref_failed;</span><br><span class="line">            &#125;</span><br><span class="line">            if (ref-&gt;node-&gt;proc &#x3D;&#x3D; target_proc) &#123;</span><br><span class="line">                if (fp-&gt;type &#x3D;&#x3D; BINDER_TYPE_HANDLE)</span><br><span class="line">                    fp-&gt;type &#x3D; BINDER_TYPE_BINDER;</span><br><span class="line">                else</span><br><span class="line">                    fp-&gt;type &#x3D; BINDER_TYPE_WEAK_BINDER;</span><br><span class="line">                fp-&gt;binder &#x3D; ref-&gt;node-&gt;ptr;</span><br><span class="line">                fp-&gt;cookie &#x3D; ref-&gt;node-&gt;cookie;</span><br><span class="line">                binder_inc_node(ref-&gt;node, fp-&gt;type &#x3D;&#x3D; BINDER_TYPE_BINDER, 0, NULL);</span><br><span class="line">                trace_binder_transaction_ref_to_node(t, ref);</span><br><span class="line">                binder_debug(BINDER_DEBUG_TRANSACTION,</span><br><span class="line">                         &quot;        ref %d desc %d -&gt; node %d u%016llx\n&quot;,</span><br><span class="line">                         ref-&gt;debug_id, ref-&gt;desc, ref-&gt;node-&gt;debug_id,</span><br><span class="line">                         (u64)ref-&gt;node-&gt;ptr);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                struct binder_ref *new_ref;</span><br><span class="line"></span><br><span class="line">                new_ref &#x3D; binder_get_ref_for_node(target_proc, ref-&gt;node);</span><br><span class="line">                if (new_ref &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                    return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">                    goto err_binder_get_ref_for_node_failed;</span><br><span class="line">                &#125;</span><br><span class="line">                fp-&gt;handle &#x3D; new_ref-&gt;desc;</span><br><span class="line">                binder_inc_ref(new_ref, fp-&gt;type &#x3D;&#x3D; BINDER_TYPE_HANDLE, NULL);</span><br><span class="line">                trace_binder_transaction_ref_to_ref(t, ref,</span><br><span class="line">                                    new_ref);</span><br><span class="line">                binder_debug(BINDER_DEBUG_TRANSACTION,</span><br><span class="line">                         &quot;        ref %d desc %d -&gt; ref %d desc %d (node %d)\n&quot;,</span><br><span class="line">                         ref-&gt;debug_id, ref-&gt;desc, new_ref-&gt;debug_id,</span><br><span class="line">                         new_ref-&gt;desc, ref-&gt;node-&gt;debug_id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">        case BINDER_TYPE_FD: &#123;</span><br><span class="line">            int target_fd;</span><br><span class="line">            struct file *file;</span><br><span class="line"></span><br><span class="line">            if (reply) &#123;</span><br><span class="line">                if (!(in_reply_to-&gt;flags &amp; TF_ACCEPT_FDS)) &#123;</span><br><span class="line">                    binder_user_error(&quot;%d:%d got reply with fd, %d, but target does not allow fds\n&quot;,</span><br><span class="line">                        proc-&gt;pid, thread-&gt;pid, fp-&gt;handle);</span><br><span class="line">                    return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">                    goto err_fd_not_allowed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (!target_node-&gt;accept_fds) &#123;</span><br><span class="line">                binder_user_error(&quot;%d:%d got transaction with fd, %d, but target does not allow fds\n&quot;,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid, fp-&gt;handle);</span><br><span class="line">                return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">                goto err_fd_not_allowed;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            file &#x3D; fget(fp-&gt;handle);</span><br><span class="line">            if (file &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">                binder_user_error(&quot;%d:%d got transaction with invalid fd, %d\n&quot;,</span><br><span class="line">                    proc-&gt;pid, thread-&gt;pid, fp-&gt;handle);</span><br><span class="line">                return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">                goto err_fget_failed;</span><br><span class="line">            &#125;</span><br><span class="line">            if (security_binder_transfer_file(proc-&gt;tsk, target_proc-&gt;tsk, file) &lt; 0) &#123;</span><br><span class="line">                fput(file);</span><br><span class="line">                return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">                goto err_get_unused_fd_failed;</span><br><span class="line">            &#125;</span><br><span class="line">            target_fd &#x3D; task_get_unused_fd_flags(target_proc, O_CLOEXEC);</span><br><span class="line">            if (target_fd &lt; 0) &#123;</span><br><span class="line">                fput(file);</span><br><span class="line">                return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">                goto err_get_unused_fd_failed;</span><br><span class="line">            &#125;</span><br><span class="line">            task_fd_install(target_proc, target_fd, file);</span><br><span class="line">            trace_binder_transaction_fd(t, fp-&gt;handle, target_fd);</span><br><span class="line">            binder_debug(BINDER_DEBUG_TRANSACTION,</span><br><span class="line">                     &quot;        fd %d -&gt; %d\n&quot;, fp-&gt;handle, target_fd);</span><br><span class="line">            &#x2F;* TODO: fput? *&#x2F;</span><br><span class="line">            fp-&gt;handle &#x3D; target_fd;</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            binder_user_error(&quot;%d:%d got transaction with invalid object type, %x\n&quot;,</span><br><span class="line">                proc-&gt;pid, thread-&gt;pid, fp-&gt;type);</span><br><span class="line">            return_error &#x3D; BR_FAILED_REPLY;</span><br><span class="line">            goto err_bad_object_type;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (reply) &#123;</span><br><span class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction !&#x3D; 0);</span><br><span class="line">        binder_pop_transaction(target_thread, in_reply_to);</span><br><span class="line">    &#125; else if (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;</span><br><span class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction !&#x3D; 0);</span><br><span class="line">        t-&gt;need_reply &#x3D; 1;</span><br><span class="line">        t-&gt;from_parent &#x3D; thread-&gt;transaction_stack;</span><br><span class="line">        thread-&gt;transaction_stack &#x3D; t;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        BUG_ON(target_node &#x3D;&#x3D; NULL);</span><br><span class="line">        BUG_ON(t-&gt;buffer-&gt;async_transaction !&#x3D; 1);</span><br><span class="line">        if (target_node-&gt;has_async_transaction) &#123;</span><br><span class="line">            target_list &#x3D; &amp;target_node-&gt;async_todo;</span><br><span class="line">            target_wait &#x3D; NULL;</span><br><span class="line">        &#125; else</span><br><span class="line">            target_node-&gt;has_async_transaction &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;work.type &#x3D; BINDER_WORK_TRANSACTION;</span><br><span class="line">    list_add_tail(&amp;t-&gt;work.entry, target_list);</span><br><span class="line">    tcomplete-&gt;type &#x3D; BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);</span><br><span class="line">    if (target_wait)</span><br><span class="line">        wake_up_interruptible(target_wait);</span><br><span class="line">    return;</span><br><span class="line"></span><br><span class="line">err_get_unused_fd_failed:</span><br><span class="line">err_fget_failed:</span><br><span class="line">err_fd_not_allowed:</span><br><span class="line">err_binder_get_ref_for_node_failed:</span><br><span class="line">err_binder_get_ref_failed:</span><br><span class="line">err_binder_new_node_failed:</span><br><span class="line">err_bad_object_type:</span><br><span class="line">err_bad_offset:</span><br><span class="line">err_copy_data_failed:</span><br><span class="line">    trace_binder_transaction_failed_buffer_release(t-&gt;buffer);</span><br><span class="line">    binder_transaction_buffer_release(target_proc, t-&gt;buffer, offp);</span><br><span class="line">    t-&gt;buffer-&gt;transaction &#x3D; NULL;</span><br><span class="line">    binder_free_buf(target_proc, t-&gt;buffer);</span><br><span class="line">err_binder_alloc_buf_failed:</span><br><span class="line">    kfree(tcomplete);</span><br><span class="line">    binder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line">err_alloc_tcomplete_failed:</span><br><span class="line">    kfree(t);</span><br><span class="line">    binder_stats_deleted(BINDER_STAT_TRANSACTION);</span><br><span class="line">err_alloc_t_failed:</span><br><span class="line">err_bad_call_stack:</span><br><span class="line">err_empty_call_stack:</span><br><span class="line">err_dead_binder:</span><br><span class="line">err_invalid_target_handle:</span><br><span class="line">err_no_context_mgr_node:</span><br><span class="line">    binder_debug(BINDER_DEBUG_FAILED_TRANSACTION,</span><br><span class="line">             &quot;%d:%d transaction failed %d, size %lld-%lld\n&quot;,</span><br><span class="line">             proc-&gt;pid, thread-&gt;pid, return_error,</span><br><span class="line">             (u64)tr-&gt;data_size, (u64)tr-&gt;offsets_size);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        struct binder_transaction_log_entry *fe;</span><br><span class="line"></span><br><span class="line">        fe &#x3D; binder_transaction_log_add(&amp;binder_transaction_log_failed);</span><br><span class="line">        *fe &#x3D; *e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BUG_ON(thread-&gt;return_error !&#x3D; BR_OK);</span><br><span class="line">    if (in_reply_to) &#123;</span><br><span class="line">        thread-&gt;return_error &#x3D; BR_TRANSACTION_COMPLETE;</span><br><span class="line">        binder_send_failed_reply(in_reply_to, return_error);</span><br><span class="line">    &#125; else</span><br><span class="line">        thread-&gt;return_error &#x3D; return_error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>2 ServiceManager</h1><br>
<h2>2.1 ServiceManager启动</h2><br>
发生在init.rc中,重启会导致其他系统服务一起重启(zygote, media, surfacefinger, drm)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">service servicemanager &#x2F;system&#x2F;bin&#x2F;servicemanager</span><br><span class="line">	class core</span><br><span class="line">	user system</span><br><span class="line">	group system</span><br><span class="line">	critical</span><br><span class="line">	onrestart restart zygote&#x2F;*(受精卵?!!!)*&#x2F;</span><br><span class="line">	onrestart restart media</span><br><span class="line">	onrestart restart surfacefinger</span><br><span class="line">	onrestart restart drm</span><br></pre></td></tr></table></figure>
<br>
<h2>2.2 ServiceManager构建</h2><br>
从/frameworks/native/cmds/servicemanager/service_manager.c的main()开始,执行了:1.binder_open();2.binder_become_context_manager();3.binder_loop()方法.

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;service_manager.c *&#x2F;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    struct binder_state *bs;</span><br><span class="line">    union selinux_callback cb;</span><br><span class="line">    char *driver;</span><br><span class="line"></span><br><span class="line">    if (argc &gt; 1) &#123;</span><br><span class="line">        driver &#x3D; argv[1];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        driver &#x3D; &quot;&#x2F;dev&#x2F;binder&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 得到关于新binder的相关信息</span><br><span class="line">    bs &#x3D; binder_open(driver, 128*1024); </span><br><span class="line">    if (!bs) &#123;</span><br><span class="line">#ifdef VENDORSERVICEMANAGER</span><br><span class="line">        ALOGW(&quot;failed to open binder driver %s\n&quot;, driver);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            sleep(UINT_MAX);</span><br><span class="line">        &#125;</span><br><span class="line">#else</span><br><span class="line">        ALOGE(&quot;failed to open binder driver %s\n&quot;, driver);</span><br><span class="line">#endif</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (binder_become_context_manager(bs)) &#123; &#x2F;&#x2F; 将这个binder设置为manager</span><br><span class="line">        ALOGE(&quot;cannot become context manager (%s)\n&quot;, strerror(errno));</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cb.func_audit &#x3D; audit_callback;</span><br><span class="line">    selinux_set_callback(SELINUX_CB_AUDIT, cb);</span><br><span class="line">    cb.func_log &#x3D; selinux_log_callback;</span><br><span class="line">    selinux_set_callback(SELINUX_CB_LOG, cb);</span><br><span class="line"></span><br><span class="line">#ifdef VENDORSERVICEMANAGER</span><br><span class="line">    sehandle &#x3D; selinux_android_vendor_service_context_handle();</span><br><span class="line">#else</span><br><span class="line">    sehandle &#x3D; selinux_android_service_context_handle();</span><br><span class="line">#endif</span><br><span class="line">    selinux_status_open(true);</span><br><span class="line"></span><br><span class="line">    if (sehandle &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        ALOGE(&quot;SELinux: Failed to acquire sehandle. Aborting.\n&quot;);</span><br><span class="line">        abort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (getcon(&amp;service_manager_context) !&#x3D; 0) &#123;</span><br><span class="line">        ALOGE(&quot;SELinux: Failed to acquire service_manager context. Aborting.\n&quot;);</span><br><span class="line">        abort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    binder_loop(bs, svcmgr_handler); &#x2F;&#x2F; 循环等待</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3>2.2.1 binder_open()</h3><br>
首先执行binder_open()方法,首先先执行了open()方法打开Binder驱动节点,然后执行mmap()方法,作用在上面[1.Binder驱动]中提到.

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.c *&#x2F;</span><br><span class="line">struct binder_state</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    void *mapped;</span><br><span class="line">    size_t mapsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.c *&#x2F;</span><br><span class="line">struct binder_state *binder_open(const char* driver, size_t mapsize)</span><br><span class="line">&#123;</span><br><span class="line">    struct binder_state *bs;</span><br><span class="line">    struct binder_version vers;</span><br><span class="line"></span><br><span class="line">    bs &#x3D; malloc(sizeof(*bs));</span><br><span class="line">    if (!bs) &#123;</span><br><span class="line">        errno &#x3D; ENOMEM;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;fd &#x3D; open(driver, O_RDWR | O_CLOEXEC); &#x2F;&#x2F; </span><br><span class="line">    if (bs-&gt;fd &lt; 0) &#123;</span><br><span class="line">        fprintf(stderr,&quot;binder: cannot open %s (%s)\n&quot;,</span><br><span class="line">                driver, strerror(errno));</span><br><span class="line">        goto fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((ioctl(bs-&gt;fd, BINDER_VERSION, &amp;vers) &#x3D;&#x3D; -1) || &#x2F;&#x2F; </span><br><span class="line">        (vers.protocol_version !&#x3D; BINDER_CURRENT_PROTOCOL_VERSION)) &#123;</span><br><span class="line">        fprintf(stderr,</span><br><span class="line">                &quot;binder: kernel driver version (%d) differs from user space version (%d)\n&quot;,</span><br><span class="line">                vers.protocol_version, BINDER_CURRENT_PROTOCOL_VERSION);</span><br><span class="line">        goto fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;mapsize &#x3D; mapsize;</span><br><span class="line">    &#x2F;&#x2F; 在用户空间开辟一块mapsize的空间</span><br><span class="line">    bs-&gt;mapped &#x3D; mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0);</span><br><span class="line">    if (bs-&gt;mapped &#x3D;&#x3D; MAP_FAILED) &#123;</span><br><span class="line">        fprintf(stderr,&quot;binder: cannot map device (%s)\n&quot;,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        goto fail_map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bs;</span><br><span class="line"></span><br><span class="line">fail_map:</span><br><span class="line">    close(bs-&gt;fd);</span><br><span class="line">fail_open:</span><br><span class="line">    free(bs);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3>2.2.2 binder_become_context_manager()</h3><br>
接着执行binder_become_context_manager()方法,可以看到直接通过ioctl(BINDER_SET_CONTEXT_MGR)方法设置为service管理者,从上面binder_open()的代码看,service manager唯一.

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.c *&#x2F;</span><br><span class="line">int binder_become_context_manager(struct binder_state *bs)</span><br><span class="line">&#123;</span><br><span class="line">    return ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3>2.2.3 binder_loop()</h3><br>
最后执行binder_loop()方法,一直循环处理消息,执行ioctl(BINDER_WRITE_READ)和binder_parse()方法.需要做的就是回复消息或者是处理与service相关的工作,比如get,add,serviceList等,正是service manager需要做的事情.

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct binder_write_read暂缺</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.c *&#x2F;</span><br><span class="line">void binder_loop(struct binder_state *bs, binder_handler func)</span><br><span class="line">&#123;</span><br><span class="line">    int res;</span><br><span class="line">    struct binder_write_read bwr;</span><br><span class="line">    uint32_t readbuf[32];</span><br><span class="line"></span><br><span class="line">    bwr.write_size &#x3D; 0;</span><br><span class="line">    bwr.write_consumed &#x3D; 0;</span><br><span class="line">    bwr.write_buffer &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    readbuf[0] &#x3D; BC_ENTER_LOOPER;</span><br><span class="line">    binder_write(bs, readbuf, sizeof(uint32_t));</span><br><span class="line"></span><br><span class="line">    for (;;) &#123; &#x2F;&#x2F; 循环执行</span><br><span class="line">        bwr.read_size &#x3D; sizeof(readbuf);</span><br><span class="line">        bwr.read_consumed &#x3D; 0;</span><br><span class="line">        bwr.read_buffer &#x3D; (uintptr_t) readbuf;</span><br><span class="line"></span><br><span class="line">        res &#x3D; ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); &#x2F;&#x2F; 拿取消息</span><br><span class="line"></span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            ALOGE(&quot;binder_loop: ioctl failed (%s)\n&quot;, strerror(errno));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res &#x3D; binder_parse(bs, 0, (uintptr_t) readbuf, bwr.read_consumed, func); &#x2F;&#x2F;解析</span><br><span class="line">        if (res &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            ALOGE(&quot;binder_loop: unexpected reply?!\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            ALOGE(&quot;binder_loop: io error %d %s\n&quot;, res, strerror(errno));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ioctl(BINDER_WRITE_READ)就是读写,主要看binder_parse()方法,该方法while分支中BR_TRANSACTION和BR_REPLY作为重点.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.c *&#x2F;</span><br><span class="line">int binder_parse(struct binder_state *bs, struct binder_io *bio,</span><br><span class="line">                 uintptr_t ptr, size_t size, binder_handler func)</span><br><span class="line">&#123;</span><br><span class="line">    int r &#x3D; 1;</span><br><span class="line">    uintptr_t end &#x3D; ptr + (uintptr_t) size;</span><br><span class="line"></span><br><span class="line">    while (ptr &lt; end) &#123;</span><br><span class="line">        uint32_t cmd &#x3D; *(uint32_t *) ptr;</span><br><span class="line">        ptr +&#x3D; sizeof(uint32_t);</span><br><span class="line">#if TRACE</span><br><span class="line">        fprintf(stderr,&quot;%s:\n&quot;, cmd_name(cmd));</span><br><span class="line">#endif</span><br><span class="line">        switch(cmd) &#123;</span><br><span class="line">        case BR_NOOP:</span><br><span class="line">            break;</span><br><span class="line">        case BR_TRANSACTION_COMPLETE:</span><br><span class="line">            break;</span><br><span class="line">        case BR_INCREFS:</span><br><span class="line">        case BR_ACQUIRE:</span><br><span class="line">        case BR_RELEASE:</span><br><span class="line">        case BR_DECREFS:</span><br><span class="line">#if TRACE</span><br><span class="line">            fprintf(stderr,&quot;  %p, %p\n&quot;, (void *)ptr, (void *)(ptr + sizeof(void *)));</span><br><span class="line">#endif</span><br><span class="line">            ptr +&#x3D; sizeof(struct binder_ptr_cookie);</span><br><span class="line">            break;</span><br><span class="line">        case BR_TRANSACTION: &#123;</span><br><span class="line">            struct binder_transaction_data *txn &#x3D; (struct binder_transaction_data *) ptr;</span><br><span class="line">            if ((end - ptr) &lt; sizeof(*txn)) &#123;</span><br><span class="line">                ALOGE(&quot;parse: txn too small!\n&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            if (func) &#123; &#x2F;&#x2F;svcmgr_handler()函数</span><br><span class="line">                unsigned rdata[256&#x2F;4];</span><br><span class="line">                struct binder_io msg;</span><br><span class="line">                struct binder_io reply;</span><br><span class="line">                int res;</span><br><span class="line"></span><br><span class="line">                bio_init(&amp;reply, rdata, sizeof(rdata), 4);</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                res &#x3D; func(bs, txn, &amp;msg, &amp;reply); &#x2F;&#x2F;svcmgr_handler()函数</span><br><span class="line">                if (txn-&gt;flags &amp; TF_ONE_WAY) &#123;</span><br><span class="line">                    binder_free_buffer(bs, txn-&gt;data.ptr.buffer);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr +&#x3D; sizeof(*txn);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case BR_REPLY: &#123;</span><br><span class="line">            struct binder_transaction_data *txn &#x3D; (struct binder_transaction_data *) ptr;</span><br><span class="line">            if ((end - ptr) &lt; sizeof(*txn)) &#123;</span><br><span class="line">                ALOGE(&quot;parse: reply too small!\n&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            if (bio) &#123;</span><br><span class="line">                bio_init_from_txn(bio, txn);</span><br><span class="line">                bio &#x3D; 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;* todo FREE BUFFER *&#x2F;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr +&#x3D; sizeof(*txn);</span><br><span class="line">            r &#x3D; 0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case BR_DEAD_BINDER: &#123;</span><br><span class="line">            struct binder_death *death &#x3D; (struct binder_death *)(uintptr_t) *(binder_uintptr_t *)ptr;</span><br><span class="line">            ptr +&#x3D; sizeof(binder_uintptr_t);</span><br><span class="line">            death-&gt;func(bs, death-&gt;ptr);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case BR_FAILED_REPLY:</span><br><span class="line">            r &#x3D; -1;</span><br><span class="line">            break;</span><br><span class="line">        case BR_DEAD_REPLY:</span><br><span class="line">            r &#x3D; -1;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            ALOGE(&quot;parse: OOPS %d\n&quot;, cmd);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看BR_TRANSACTION,首先执行了func()方法赋值给res(func()是svcmgr_handler()),该方法提供了SVC_MGR_GET_SERVICE,SVC_MGR_CHECK_SERVICE获得handler;SVC_MGR_ADD_SERVICE添加;SVC_MGR_LIST_SERVICES返回列表.无论哪个分支最终都会将reply回复.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;service_manager.c *&#x2F;</span><br><span class="line">int svcmgr_handler(struct binder_state *bs,</span><br><span class="line">                   struct binder_transaction_data *txn,</span><br><span class="line">                   struct binder_io *msg,</span><br><span class="line">                   struct binder_io *reply)</span><br><span class="line">&#123;</span><br><span class="line">    struct svcinfo *si;</span><br><span class="line">    uint16_t *s;</span><br><span class="line">    size_t len;</span><br><span class="line">    uint32_t handle;</span><br><span class="line">    uint32_t strict_policy;</span><br><span class="line">    int allow_isolated;</span><br><span class="line">    uint32_t dumpsys_priority;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;ALOGI(&quot;target&#x3D;%p code&#x3D;%d pid&#x3D;%d uid&#x3D;%d\n&quot;,</span><br><span class="line">    &#x2F;&#x2F;      (void*) txn-&gt;target.ptr, txn-&gt;code, txn-&gt;sender_pid, txn-&gt;sender_euid);</span><br><span class="line"></span><br><span class="line">    if (txn-&gt;target.ptr !&#x3D; BINDER_SERVICE_MANAGER)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    if (txn-&gt;code &#x3D;&#x3D; PING_TRANSACTION)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Equivalent to Parcel::enforceInterface(), reading the RPC</span><br><span class="line">    &#x2F;&#x2F; header with the strict mode policy mask and the interface name.</span><br><span class="line">    &#x2F;&#x2F; Note that we ignore the strict_policy and don&#39;t propagate it</span><br><span class="line">    &#x2F;&#x2F; further (since we do no outbound RPCs anyway).</span><br><span class="line">    strict_policy &#x3D; bio_get_uint32(msg);</span><br><span class="line">    s &#x3D; bio_get_string16(msg, &amp;len);</span><br><span class="line">    if (s &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((len !&#x3D; (sizeof(svcmgr_id) &#x2F; 2)) ||</span><br><span class="line">        memcmp(svcmgr_id, s, sizeof(svcmgr_id))) &#123;</span><br><span class="line">        fprintf(stderr,&quot;invalid id %s\n&quot;, str8(s, len));</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (sehandle &amp;&amp; selinux_status_updated() &gt; 0) &#123;</span><br><span class="line">#ifdef VENDORSERVICEMANAGER</span><br><span class="line">        struct selabel_handle *tmp_sehandle &#x3D; selinux_android_vendor_service_context_handle();</span><br><span class="line">#else</span><br><span class="line">        struct selabel_handle *tmp_sehandle &#x3D; selinux_android_service_context_handle();</span><br><span class="line">#endif</span><br><span class="line">        if (tmp_sehandle) &#123;</span><br><span class="line">            selabel_close(sehandle);</span><br><span class="line">            sehandle &#x3D; tmp_sehandle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch(txn-&gt;code) &#123;</span><br><span class="line">    case SVC_MGR_GET_SERVICE:</span><br><span class="line">    case SVC_MGR_CHECK_SERVICE:</span><br><span class="line">        s &#x3D; bio_get_string16(msg, &amp;len);</span><br><span class="line">        if (s &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        handle &#x3D; do_find_service(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid);</span><br><span class="line">        if (!handle)</span><br><span class="line">            break;</span><br><span class="line">        bio_put_ref(reply, handle);</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    case SVC_MGR_ADD_SERVICE:</span><br><span class="line">        s &#x3D; bio_get_string16(msg, &amp;len);</span><br><span class="line">        if (s &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        handle &#x3D; bio_get_ref(msg);</span><br><span class="line">        allow_isolated &#x3D; bio_get_uint32(msg) ? 1 : 0;</span><br><span class="line">        dumpsys_priority &#x3D; bio_get_uint32(msg);</span><br><span class="line">        if (do_add_service(bs, s, len, handle, txn-&gt;sender_euid, allow_isolated, dumpsys_priority,</span><br><span class="line">                           txn-&gt;sender_pid))</span><br><span class="line">            return -1;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case SVC_MGR_LIST_SERVICES: &#123;</span><br><span class="line">        uint32_t n &#x3D; bio_get_uint32(msg);</span><br><span class="line">        uint32_t req_dumpsys_priority &#x3D; bio_get_uint32(msg);</span><br><span class="line"></span><br><span class="line">        if (!svc_can_list(txn-&gt;sender_pid, txn-&gt;sender_euid)) &#123;</span><br><span class="line">            ALOGE(&quot;list_service() uid&#x3D;%d - PERMISSION DENIED\n&quot;,</span><br><span class="line">                    txn-&gt;sender_euid);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        si &#x3D; svclist;</span><br><span class="line">        &#x2F;&#x2F; walk through the list of services n times skipping services that</span><br><span class="line">        &#x2F;&#x2F; do not support the requested priority</span><br><span class="line">        while (si) &#123;</span><br><span class="line">            if (si-&gt;dumpsys_priority &amp; req_dumpsys_priority) &#123;</span><br><span class="line">                if (n &#x3D;&#x3D; 0) break;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            si &#x3D; si-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (si) &#123;</span><br><span class="line">            bio_put_string16(reply, si-&gt;name);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    default:</span><br><span class="line">        ALOGE(&quot;unknown code %d\n&quot;, txn-&gt;code);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bio_put_uint32(reply, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再回过头看BR_REPLY, 根据书上所说,该分支并没有实质动作,因为SM没有向其他Binder Server主动发起请求的情况.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">case BR_REPLY: &#123;</span><br><span class="line">            struct binder_transaction_data *txn &#x3D; (struct binder_transaction_data *) ptr;</span><br><span class="line">            if ((end - ptr) &lt; sizeof(*txn)) &#123;</span><br><span class="line">                ALOGE(&quot;parse: reply too small!\n&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            if (bio) &#123;</span><br><span class="line">                bio_init_from_txn(bio, txn);</span><br><span class="line">                bio &#x3D; 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;* todo FREE BUFFER *&#x2F;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr +&#x3D; sizeof(*txn);</span><br><span class="line">            r &#x3D; 0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<br>
具体流程如图:

<p><img src="https://guaong.github.io/guaong.github.io/2020/02/02/Android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1Binder/03.png" alt="流程"><br><br></p>
<h2>2.3 获取ServiceManager服务</h2><br>
客户端Binder会通过getService()方法从SM中获得一个IBinder.下面三段代码中最重要的就是第三段rawGetService()中执行的getIServiceManager().getService(name)这行代码,这行代码分为两个部分:1.getIServiceManager();2.getService().

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final class ServiceManager &#123;</span><br><span class="line">    public static IBinder getService(String name) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            IBinder service &#x3D; sCache.get(name);</span><br><span class="line">            if (service !&#x3D; null) &#123;</span><br><span class="line">                return service;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return Binder.allowBlocking(rawGetService(name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in getService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Binder implements IBinder &#123;</span><br><span class="line">    public static IBinder allowBlocking(IBinder binder) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (binder instanceof BinderProxy) &#123;</span><br><span class="line">                ((BinderProxy) binder).mWarnOnBlocking &#x3D; false;</span><br><span class="line">            &#125; else if (binder !&#x3D; null &amp;&amp; binder.getInterfaceDescriptor() !&#x3D; null</span><br><span class="line">                    &amp;&amp; binder.queryLocalInterface(binder.getInterfaceDescriptor()) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Unable to allow blocking on interface &quot; + binder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        return binder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public final class ServiceManager &#123;</span><br><span class="line">    private static IBinder rawGetService(String name) throws RemoteException &#123;</span><br><span class="line">        final long start &#x3D; sStatLogger.getTime();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 上面代码实际的getService()方法,接下来将分为getIServiceManager()和getService()分析</span><br><span class="line">        final IBinder binder &#x3D; getIServiceManager().getService(name);</span><br><span class="line"></span><br><span class="line">        final int time &#x3D; (int) sStatLogger.logDurationStat(Stats.GET_SERVICE, start);</span><br><span class="line"></span><br><span class="line">        final int myUid &#x3D; Process.myUid();</span><br><span class="line">        final boolean isCore &#x3D; UserHandle.isCore(myUid);</span><br><span class="line"></span><br><span class="line">        final long slowThreshold &#x3D; isCore</span><br><span class="line">                ? GET_SERVICE_SLOW_THRESHOLD_US_CORE</span><br><span class="line">                : GET_SERVICE_SLOW_THRESHOLD_US_NON_CORE;</span><br><span class="line"></span><br><span class="line">        synchronized (sLock) &#123;</span><br><span class="line">            sGetServiceAccumulatedUs +&#x3D; time;</span><br><span class="line">            sGetServiceAccumulatedCallCount++;</span><br><span class="line"></span><br><span class="line">            final long nowUptime &#x3D; SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Was a slow call?</span><br><span class="line">            if (time &gt;&#x3D; slowThreshold) &#123;</span><br><span class="line">                &#x2F;&#x2F; We do a slow log:</span><br><span class="line">                &#x2F;&#x2F; - At most once in every SLOW_LOG_INTERVAL_MS</span><br><span class="line">                &#x2F;&#x2F; - OR it was slower than the previously logged slow call.</span><br><span class="line">                if ((nowUptime &gt; (sLastSlowLogUptime + SLOW_LOG_INTERVAL_MS))</span><br><span class="line">                        || (sLastSlowLogActualTime &lt; time)) &#123;</span><br><span class="line">                    EventLogTags.writeServiceManagerSlow(time &#x2F; 1000, name);</span><br><span class="line"></span><br><span class="line">                    sLastSlowLogUptime &#x3D; nowUptime;</span><br><span class="line">                    sLastSlowLogActualTime &#x3D; time;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Every GET_SERVICE_LOG_EVERY_CALLS calls, log the total time spent in getService().</span><br><span class="line"></span><br><span class="line">            final int logInterval &#x3D; isCore</span><br><span class="line">                    ? GET_SERVICE_LOG_EVERY_CALLS_CORE</span><br><span class="line">                    : GET_SERVICE_LOG_EVERY_CALLS_NON_CORE;</span><br><span class="line"></span><br><span class="line">            if ((sGetServiceAccumulatedCallCount &gt;&#x3D; logInterval)</span><br><span class="line">                    &amp;&amp; (nowUptime &gt;&#x3D; (sLastStatsLogUptime + STATS_LOG_INTERVAL_MS))) &#123;</span><br><span class="line"></span><br><span class="line">                EventLogTags.writeServiceManagerStats(</span><br><span class="line">                        sGetServiceAccumulatedCallCount, &#x2F;&#x2F; Total # of getService() calls.</span><br><span class="line">                        sGetServiceAccumulatedUs &#x2F; 1000, &#x2F;&#x2F; Total time spent in getService() calls.</span><br><span class="line">                        (int) (nowUptime - sLastStatsLogUptime)); &#x2F;&#x2F; Uptime duration since last log.</span><br><span class="line">                sGetServiceAccumulatedCallCount &#x3D; 0;</span><br><span class="line">                sGetServiceAccumulatedUs &#x3D; 0;</span><br><span class="line">                sLastStatsLogUptime &#x3D; nowUptime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return binder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3>2.3.1 getIServiceManager()</h3><br>
首先先看getIServiceManager()方法.在该方法中主要看ServiceManagerNative.
asInterface(Binder.allowBlocking(BinderInternal.getContextObject()))这行代码,这行代码分为两块:1.asInterface();2.getContextObject().

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public final class ServiceManager &#123;</span><br><span class="line">    private static IServiceManager getIServiceManager() &#123;</span><br><span class="line">        if (sServiceManager !&#x3D; null) &#123;</span><br><span class="line">            return sServiceManager;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Find the service manager</span><br><span class="line">        &#x2F;&#x2F; BinderInternal.getContextObject()得到的是来自ProcessState创建的BpBinder,在Java层也就是BinderProxy</span><br><span class="line">        &#x2F;&#x2F; asInterface()得到一个ServiceManagerProxy,并且这个代理里面有一个BinderProxy</span><br><span class="line">        sServiceManager &#x3D; ServiceManagerNative</span><br><span class="line">                .asInterface(Binder.allowBlocking(BinderInternal.getContextObject()));</span><br><span class="line">        return sServiceManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h4>2.3.1.1 getContextObject()</h4><br>
在研究asInterface()方法之前,先分析getContextObject()方法向asInterface()方法中传递的什么对象.(ps.代码很多)
可以看到该方法调用的时native层的getContextObject()方法.

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BinderInternal &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return the global &quot;context object&quot; of the system.  This is usually</span><br><span class="line">     * an implementation of IServiceManager, which you can use to find</span><br><span class="line">     * other services.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    public static final native IBinder getContextObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据native层的android_os_util_BinderInternal_getContextObject()可以看到该方法可分为三步:1.new一个ProcessState;2.调用getContextObject();3.javaObjectForIBinder().</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Binder.cpp *&#x2F;</span><br><span class="line">static jobject android_os_util_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b &#x3D; ProcessState::self()-&gt;getContextObject(NULL);</span><br><span class="line">    return javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h5>2.3.1.1.1 ProcessState::self()</h5><br>
首先先看new一个ProcessState.根据构造方法代码可以看到ProcessState对象gProcess只能有一个,在没有该对象时要实例化一个对象.

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;ProcessState.cpp *&#x2F;</span><br><span class="line">sp&lt;ProcessState&gt; ProcessState::self()</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    if (gProcess !&#x3D; NULL) &#123;</span><br><span class="line">        return gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    gProcess &#x3D; new ProcessState(&quot;&#x2F;dev&#x2F;binder&quot;);</span><br><span class="line">    return gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实例化对象时,执行了open_driver()和mmap().和/frameworks/native/cmds/servicemanager/service_manager.c的main()执行的一样.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;ProcessState.cpp *&#x2F;</span><br><span class="line">ProcessState::ProcessState(const char *driver)</span><br><span class="line">    : mDriverName(String8(driver))</span><br><span class="line">    , mDriverFD(open_driver(driver))</span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(0)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(0)</span><br><span class="line">    , mManagesContexts(false)</span><br><span class="line">    , mBinderContextCheckFunc(NULL)</span><br><span class="line">    , mBinderContextUserData(NULL)</span><br><span class="line">    , mThreadPoolStarted(false)</span><br><span class="line">    , mThreadPoolSeq(1)</span><br><span class="line">&#123;</span><br><span class="line">    if (mDriverFD &gt;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; mmap the binder, providing a chunk of virtual address space to receive transactions.</span><br><span class="line">        mVMStart &#x3D; mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);</span><br><span class="line">        if (mVMStart &#x3D;&#x3D; MAP_FAILED) &#123;</span><br><span class="line">            &#x2F;&#x2F; *sigh*</span><br><span class="line">            ALOGE(&quot;Using %s failed: unable to mmap transaction memory.\n&quot;, mDriverName.c_str());</span><br><span class="line">            close(mDriverFD);</span><br><span class="line">            mDriverFD &#x3D; -1;</span><br><span class="line">            mDriverName.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mDriverFD &lt; 0, &quot;Binder driver could not be opened.  Terminating.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h5>2.3.1.1.2 getContextObject()</h5><br>
再看getContextObject(),实质是执行getStrongProxyForHandle()方法.

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;ProcessState.cpp *&#x2F;</span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; &#x2F;*caller*&#x2F;)</span><br><span class="line">&#123;</span><br><span class="line">    return getStrongProxyForHandle(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在getStrongProxyForHandle()方法中执行了BpBinder::create(handle);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;ProcessState.cpp *&#x2F;</span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    handle_entry* e &#x3D; lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    if (e !&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F; We need to create a new BpBinder if there isn&#39;t currently one, OR we</span><br><span class="line">        &#x2F;&#x2F; are unable to acquire a weak reference on this current one.  See comment</span><br><span class="line">        &#x2F;&#x2F; in getWeakProxyForHandle() for more info about this.</span><br><span class="line">        IBinder* b &#x3D; e-&gt;binder;</span><br><span class="line">        if (b &#x3D;&#x3D; NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123;</span><br><span class="line">            if (handle &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; Special case for context manager...</span><br><span class="line">                &#x2F;&#x2F; The context manager is the only object for which we create</span><br><span class="line">                &#x2F;&#x2F; a BpBinder proxy without already holding a reference.</span><br><span class="line">                &#x2F;&#x2F; Perform a dummy transaction to ensure the context manager</span><br><span class="line">                &#x2F;&#x2F; is registered before we create the first local reference</span><br><span class="line">                &#x2F;&#x2F; to it (which will occur when creating the BpBinder).</span><br><span class="line">                &#x2F;&#x2F; If a local reference is created for the BpBinder when the</span><br><span class="line">                &#x2F;&#x2F; context manager is not present, the driver will fail to</span><br><span class="line">                &#x2F;&#x2F; provide a reference to the context manager, but the</span><br><span class="line">                &#x2F;&#x2F; driver API does not return status.</span><br><span class="line">                &#x2F;&#x2F;</span><br><span class="line">                &#x2F;&#x2F; Note that this is not race-free if the context manager</span><br><span class="line">                &#x2F;&#x2F; dies while this code runs.</span><br><span class="line">                &#x2F;&#x2F;</span><br><span class="line">                &#x2F;&#x2F; TODO: add a driver API to wait for context manager, or</span><br><span class="line">                &#x2F;&#x2F; stop special casing handle 0 for context manager and add</span><br><span class="line">                &#x2F;&#x2F; a driver API to get a handle to the context manager with</span><br><span class="line">                &#x2F;&#x2F; proper reference counting.</span><br><span class="line"></span><br><span class="line">                Parcel data;</span><br><span class="line">                status_t status &#x3D; IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        0, IBinder::PING_TRANSACTION, data, NULL, 0);</span><br><span class="line">                if (status &#x3D;&#x3D; DEAD_OBJECT)</span><br><span class="line">                   return NULL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            b &#x3D; BpBinder::create(handle);</span><br><span class="line">            e-&gt;binder &#x3D; b;</span><br><span class="line">            if (b) e-&gt;refs &#x3D; b-&gt;getWeakRefs();</span><br><span class="line">            result &#x3D; b;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; This little bit of nastyness is to allow us to add a primary</span><br><span class="line">            &#x2F;&#x2F; reference to the remote proxy when this team doesn&#39;t have one</span><br><span class="line">            &#x2F;&#x2F; but another team is sending the handle to us.</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在create方法中返回了new BpBinder(handle, trackedUid).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;BpBinder.cpp *&#x2F;</span><br><span class="line">BpBinder* BpBinder::create(int32_t handle) &#123;</span><br><span class="line">    int32_t trackedUid &#x3D; -1;</span><br><span class="line">    if (sCountByUidEnabled) &#123;</span><br><span class="line">        trackedUid &#x3D; IPCThreadState::self()-&gt;getCallingUid();</span><br><span class="line">        AutoMutex _l(sTrackingLock);</span><br><span class="line">        uint32_t trackedValue &#x3D; sTrackingMap[trackedUid];</span><br><span class="line">        if (CC_UNLIKELY(trackedValue &amp; LIMIT_REACHED_MASK)) &#123;</span><br><span class="line">            if (sBinderProxyThrottleCreate) &#123;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if ((trackedValue &amp; COUNTING_VALUE_MASK) &gt;&#x3D; sBinderProxyCountHighWatermark) &#123;</span><br><span class="line">                ALOGE(&quot;Too many binder proxy objects sent to uid %d from uid %d (%d proxies held)&quot;,</span><br><span class="line">                      getuid(), trackedUid, trackedValue);</span><br><span class="line">                sTrackingMap[trackedUid] |&#x3D; LIMIT_REACHED_MASK;</span><br><span class="line">                if (sLimitCallback) sLimitCallback(trackedUid);</span><br><span class="line">                if (sBinderProxyThrottleCreate) &#123;</span><br><span class="line">                    ALOGI(&quot;Throttling binder proxy creates from uid %d in uid %d until binder proxy&quot;</span><br><span class="line">                          &quot; count drops below %d&quot;,</span><br><span class="line">                          trackedUid, getuid(), sBinderProxyCountLowWatermark);</span><br><span class="line">                    return nullptr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sTrackingMap[trackedUid]++;</span><br><span class="line">    &#125;</span><br><span class="line">    return new BpBinder(handle, trackedUid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;BpBinder.cpp *&#x2F;</span><br><span class="line">BpBinder::BpBinder(int32_t handle, int32_t trackedUid)</span><br><span class="line">    : mHandle(handle)</span><br><span class="line">    , mAlive(1)</span><br><span class="line">    , mObitsSent(0)</span><br><span class="line">    , mObituaries(NULL)</span><br><span class="line">    , mTrackedUid(trackedUid)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(&quot;Creating BpBinder %p handle %d\n&quot;, this, mHandle);</span><br><span class="line"></span><br><span class="line">    extendObjectLifetime(OBJECT_LIFETIME_WEAK);</span><br><span class="line">    IPCThreadState::self()-&gt;incWeakHandle(handle, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp *&#x2F;</span><br><span class="line">IPCThreadState* IPCThreadState::self()</span><br><span class="line">&#123;</span><br><span class="line">    if (gHaveTLS) &#123;</span><br><span class="line">restart:</span><br><span class="line">        const pthread_key_t k &#x3D; gTLS;</span><br><span class="line">        IPCThreadState* st &#x3D; (IPCThreadState*)pthread_getspecific(k);</span><br><span class="line">        if (st) return st;</span><br><span class="line">        return new IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (gShutdown) &#123;</span><br><span class="line">        ALOGW(&quot;Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line">    if (!gHaveTLS) &#123;</span><br><span class="line">        int key_create_value &#x3D; pthread_key_create(&amp;gTLS, threadDestructor);</span><br><span class="line">        if (key_create_value !&#x3D; 0) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">            ALOGW(&quot;IPCThreadState::self() unable to create TLS key, expect a crash: %s\n&quot;,</span><br><span class="line">                    strerror(key_create_value));</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        gHaveTLS &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">    goto restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp *&#x2F;</span><br><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">    : mProcess(ProcessState::self()),</span><br><span class="line">      mStrictModePolicy(0),</span><br><span class="line">      mLastTransactionBinderFlags(0)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_setspecific(gTLS, this);</span><br><span class="line">    clearCaller();</span><br><span class="line">    mIn.setDataCapacity(256);</span><br><span class="line">    mOut.setDataCapacity(256);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp *&#x2F;</span><br><span class="line">void IPCThreadState::incWeakHandle(int32_t handle, BpBinder *proxy)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_REMOTEREFS(&quot;IPCThreadState::incWeakHandle(%d)\n&quot;, handle);</span><br><span class="line">    mOut.writeInt32(BC_INCREFS);</span><br><span class="line">    mOut.writeInt32(handle);</span><br><span class="line">    &#x2F;&#x2F; Create a temp reference until the driver has handled this command.</span><br><span class="line">    proxy-&gt;getWeakRefs()-&gt;incWeak(mProcess.get());</span><br><span class="line">    mPostWriteWeakDerefs.push(proxy-&gt;getWeakRefs());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h5>2.3.1.1.3 javaObjectForIBinder()</h5><br>
javaObjectForIBinder()方法通过JNI的NewObject()把native层ProcessState创建的BpBinder变成Java层的BinderProxy.
<br>
<h4>2.3.1.2 asInterface()</h4><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ServiceManagerNative extends Binder implements IServiceManager</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将Binder对象转换成IServiceManager if needed.或者创建一个ServiceManagerProxy对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static public IServiceManager asInterface(IBinder obj)</span><br><span class="line">    &#123;</span><br><span class="line">        if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        IServiceManager in &#x3D;</span><br><span class="line">            (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">        if (in !&#x3D; null) &#123;</span><br><span class="line">            return in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ServiceManagerProxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ServiceManagerProxy implements IServiceManager &#123;</span><br><span class="line">    public ServiceManagerProxy(IBinder remote) &#123;</span><br><span class="line">        mRemote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3>2.3.2 getService()</h3><br>
回过头看最开始的getIServiceManager().getService()中的getService()

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class ServiceManagerProxy implements IServiceManager &#123;</span><br><span class="line">    public IBinder getService(String name) throws RemoteException &#123;</span><br><span class="line">        &#x2F;&#x2F;Parcel是消息的数据包</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">        data.writeString(name);</span><br><span class="line">        &#x2F;&#x2F; mRemote是上面ServiceManagerProxy中涵盖的BinderProxy</span><br><span class="line">        &#x2F;&#x2F; 在这里执行获得服务的事务</span><br><span class="line">        mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">        IBinder binder &#x3D; reply.readStrongBinder();</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        return binder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class BinderProxy implements IBinder &#123;</span><br><span class="line">    public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">        Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);</span><br><span class="line"></span><br><span class="line">        if (mWarnOnBlocking &amp;&amp; ((flags &amp; FLAG_ONEWAY) &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">            &#x2F;&#x2F; For now, avoid spamming the log by disabling after we&#39;ve logged</span><br><span class="line">            &#x2F;&#x2F; about this interface at least once</span><br><span class="line">            mWarnOnBlocking &#x3D; false;</span><br><span class="line">            Log.w(Binder.TAG, &quot;Outgoing transactions from this process must be FLAG_ONEWAY&quot;,</span><br><span class="line">                    new Throwable());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean tracingEnabled &#x3D; Binder.isTracingEnabled();</span><br><span class="line">        if (tracingEnabled) &#123;</span><br><span class="line">            final Throwable tr &#x3D; new Throwable();</span><br><span class="line">            Binder.getTransactionTracker().addTrace(tr);</span><br><span class="line">            StackTraceElement stackTraceElement &#x3D; tr.getStackTrace()[1];</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ALWAYS,</span><br><span class="line">                    stackTraceElement.getClassName() + &quot;.&quot; + stackTraceElement.getMethodName());</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            return transactNative(code, data, reply, flags);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (tracingEnabled) &#123;</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ALWAYS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class BinderProxy implements IBinder &#123;</span><br><span class="line">    public native boolean transactNative(int code, Parcel data, Parcel reply,</span><br><span class="line">            int flags) throws RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* android_util_Binder.cpp *&#x2F;</span><br><span class="line">&#x2F;&#x2F;与上面TransactNative()方法中间应该还有步骤,但是书上没有描述</span><br><span class="line">static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,</span><br><span class="line">        jint code, jobject dataObj, jobject replyObj, jint flags) &#x2F;&#x2F; throws RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    if (dataObj &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        jniThrowNullPointerException(env, NULL);</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Parcel* data &#x3D; parcelForJavaObject(env, dataObj);</span><br><span class="line">    if (data &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    Parcel* reply &#x3D; parcelForJavaObject(env, replyObj);</span><br><span class="line">    if (reply &#x3D;&#x3D; NULL &amp;&amp; replyObj !&#x3D; NULL) &#123;</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IBinder* target &#x3D; getBPNativeData(env, obj)-&gt;mObject.get();</span><br><span class="line">    if (target &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        jniThrowException(env, &quot;java&#x2F;lang&#x2F;IllegalStateException&quot;, &quot;Binder has been finalized!&quot;);</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGV(&quot;Java code calling transact on %p in Java object %p with code %&quot; PRId32 &quot;\n&quot;,</span><br><span class="line">            target, obj, code);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bool time_binder_calls;</span><br><span class="line">    int64_t start_millis;</span><br><span class="line">    if (kEnableBinderSample) &#123;</span><br><span class="line">        &#x2F;&#x2F; Only log the binder call duration for things on the Java-level main thread.</span><br><span class="line">        &#x2F;&#x2F; But if we don&#39;t</span><br><span class="line">        time_binder_calls &#x3D; should_time_binder_calls();</span><br><span class="line"></span><br><span class="line">        if (time_binder_calls) &#123;</span><br><span class="line">            start_millis &#x3D; uptimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;printf(&quot;Transact from Java code to %p sending: &quot;, target); data-&gt;print();</span><br><span class="line">    &#x2F;&#x2F; 继续嵌套</span><br><span class="line">    status_t err &#x3D; target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">    &#x2F;&#x2F;if (reply) printf(&quot;Transact from Java code to %p received: &quot;, target); reply-&gt;print();</span><br><span class="line"></span><br><span class="line">    if (kEnableBinderSample) &#123;</span><br><span class="line">        if (time_binder_calls) &#123;</span><br><span class="line">            conditionally_log_binder_call(start_millis, target, code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (err &#x3D;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        return JNI_TRUE;</span><br><span class="line">    &#125; else if (err &#x3D;&#x3D; UNKNOWN_TRANSACTION) &#123;</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signalExceptionForError(env, obj, err, true &#x2F;*canThrowRemoteException*&#x2F;, data-&gt;dataSize());</span><br><span class="line">    return JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行到BpBinder::transact()方法,该方法中分为两步:1.IPCThreadState::self();2.IPCThreadState::self()-&gt;transact(mHandle, code, data, reply, flags).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">status_t BpBinder::transact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Once a binder has died, it will never come back to life.</span><br><span class="line">    if (mAlive) &#123;</span><br><span class="line">        &#x2F;&#x2F; 实例化一个IPCThreadState</span><br><span class="line">        &#x2F;&#x2F; 再执行transact</span><br><span class="line">        status_t status &#x3D; IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        if (status &#x3D;&#x3D; DEAD_OBJECT) mAlive &#x3D; 0;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h4>2.3.2.1 IPCThreadState::self()</h4><br>
在这里要提一下<h6>TLS(Thread Local Storage)</h6>.在一个进程中,创建一个全局变量,那么该进程中的所以线程都可以访问这个全局变量,都可以修改它.但是有的时候我们希望所有线程可以访问但是修改不受相互影响,所以就采用了TLS机制,保证每个线程拿到的都是该全局变量的副本,相互之间操作不会受到其他线程影响.(具体细节今后专门写一下)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp *&#x2F;</span><br><span class="line">IPCThreadState* IPCThreadState::self()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 在第一次时gHaveTLS是false,会执行下面的if(!gHaveTLS),然后会执行到goto restart.</span><br><span class="line">    &#x2F;&#x2F; 此时gHaveTLS&#x3D;true,如果该线程已经创建过IPCThreadState,pthread_getspecific()就不为空</span><br><span class="line">    &#x2F;&#x2F; 否则创建一个IPCThreadState</span><br><span class="line">    &#x2F;&#x2F; 假定有好多都需要getService(),那么都会执行到这个方法,</span><br><span class="line">    &#x2F;&#x2F; 都需要IPCThreadState,但是为了保证所有用到的都是同一个IPCThreadState且不能相互影响,</span><br><span class="line">    &#x2F;&#x2F; 所以第一个执行getService()的会new IPCThreadState,之后的就只需要从pthread_getspecific()拿去唯一一个IPCThreadState的副本(大致意思).</span><br><span class="line">    if (gHaveTLS) &#123;</span><br><span class="line">restart:</span><br><span class="line">        const pthread_key_t k &#x3D; gTLS;</span><br><span class="line">        IPCThreadState* st &#x3D; (IPCThreadState*)pthread_getspecific(k);</span><br><span class="line">        if (st) return st;</span><br><span class="line">        return new IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (gShutdown) &#123;</span><br><span class="line">        ALOGW(&quot;Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line">    if (!gHaveTLS) &#123;</span><br><span class="line">        int key_create_value &#x3D; pthread_key_create(&amp;gTLS, threadDestructor);</span><br><span class="line">        if (key_create_value !&#x3D; 0) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">            ALOGW(&quot;IPCThreadState::self() unable to create TLS key, expect a crash: %s\n&quot;,</span><br><span class="line">                    strerror(key_create_value));</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        gHaveTLS &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">    goto restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp *&#x2F;</span><br><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">    : mProcess(ProcessState::self()),</span><br><span class="line">      mStrictModePolicy(0),</span><br><span class="line">      mLastTransactionBinderFlags(0)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_setspecific(gTLS, this);</span><br><span class="line">    clearCaller();</span><br><span class="line">    mIn.setDataCapacity(256);</span><br><span class="line">    mOut.setDataCapacity(256);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h4>2.3.2.2 IPCThreadState::self()->transact()</h4><br>
这是真正执行transact()方法的地方.

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp *&#x2F;</span><br><span class="line">status_t IPCThreadState::transact(int32_t handle,</span><br><span class="line">                                  uint32_t code, const Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    status_t err;</span><br><span class="line"></span><br><span class="line">    flags |&#x3D; TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">        TextOutput::Bundle _b(alog);</span><br><span class="line">        alog &lt;&lt; &quot;BC_TRANSACTION thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; &#x2F; hand &quot;</span><br><span class="line">            &lt;&lt; handle &lt;&lt; &quot; &#x2F; code &quot; &lt;&lt; TypeCode(code) &lt;&lt; &quot;: &quot;</span><br><span class="line">            &lt;&lt; indent &lt;&lt; data &lt;&lt; dedent &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_ONEWAY(&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;, getpid(), getuid(),</span><br><span class="line">        (flags &amp; TF_ONE_WAY) &#x3D;&#x3D; 0 ? &quot;READ REPLY&quot; : &quot;ONE WAY&quot;);</span><br><span class="line">    err &#x3D; writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);</span><br><span class="line"></span><br><span class="line">    if (err !&#x3D; NO_ERROR) &#123;</span><br><span class="line">        if (reply) reply-&gt;setError(err);</span><br><span class="line">        return (mLastError &#x3D; err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((flags &amp; TF_ONE_WAY) &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 传过来的flags &#x3D;&#x3D; 0</span><br><span class="line">        #if 0</span><br><span class="line">        if (code &#x3D;&#x3D; 4) &#123; &#x2F;&#x2F; relayout</span><br><span class="line">            ALOGI(&quot;&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction 4&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ALOGI(&quot;&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction %d&quot;, code);</span><br><span class="line">        &#125;</span><br><span class="line">        #endif</span><br><span class="line">        if (reply) &#123;</span><br><span class="line">            err &#x3D; waitForResponse(reply);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err &#x3D; waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">        #if 0</span><br><span class="line">        if (code &#x3D;&#x3D; 4) &#123; &#x2F;&#x2F; relayout</span><br><span class="line">            ALOGI(&quot;&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction 4&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ALOGI(&quot;&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction %d&quot;, code);</span><br><span class="line">        &#125;</span><br><span class="line">        #endif</span><br><span class="line"></span><br><span class="line">        IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">            TextOutput::Bundle _b(alog);</span><br><span class="line">            alog &lt;&lt; &quot;BR_REPLY thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; &#x2F; hand &quot;</span><br><span class="line">                &lt;&lt; handle &lt;&lt; &quot;: &quot;;</span><br><span class="line">            if (reply) alog &lt;&lt; indent &lt;&lt; *reply &lt;&lt; dedent &lt;&lt; endl;</span><br><span class="line">            else alog &lt;&lt; &quot;(none requested)&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        err &#x3D; waitForResponse(NULL, NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IPCThreadState::waitForResponse()方法分为两步:1.talkWithDriver();2.executeCommand().</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp *&#x2F;</span><br><span class="line">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t cmd;</span><br><span class="line">    int32_t err;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        if ((err&#x3D;talkWithDriver()) &lt; NO_ERROR) break;</span><br><span class="line">        err &#x3D; mIn.errorCheck(); &#x2F;&#x2F; mIn是读取用的Parcel</span><br><span class="line">        if (err &lt; NO_ERROR) break;</span><br><span class="line">        if (mIn.dataAvail() &#x3D;&#x3D; 0) continue;</span><br><span class="line"></span><br><span class="line">        cmd &#x3D; (uint32_t)mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; &quot;Processing waitForResponse Command: &quot;</span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">        case BR_TRANSACTION_COMPLETE:</span><br><span class="line">            if (!reply &amp;&amp; !acquireResult) goto finish;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case BR_DEAD_REPLY:</span><br><span class="line">            err &#x3D; DEAD_OBJECT;</span><br><span class="line">            goto finish;</span><br><span class="line"></span><br><span class="line">        case BR_FAILED_REPLY:</span><br><span class="line">            err &#x3D; FAILED_TRANSACTION;</span><br><span class="line">            goto finish;</span><br><span class="line"></span><br><span class="line">        case BR_ACQUIRE_RESULT:</span><br><span class="line">            &#123;</span><br><span class="line">                ALOG_ASSERT(acquireResult !&#x3D; NULL, &quot;Unexpected brACQUIRE_RESULT&quot;);</span><br><span class="line">                const int32_t result &#x3D; mIn.readInt32();</span><br><span class="line">                if (!acquireResult) continue;</span><br><span class="line">                *acquireResult &#x3D; result ? NO_ERROR : INVALID_OPERATION;</span><br><span class="line">            &#125;</span><br><span class="line">            goto finish;</span><br><span class="line"></span><br><span class="line">        case BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err &#x3D; mIn.read(&amp;tr, sizeof(tr));</span><br><span class="line">                ALOG_ASSERT(err &#x3D;&#x3D; NO_ERROR, &quot;Not enough command data for brREPLY&quot;);</span><br><span class="line">                if (err !&#x3D; NO_ERROR) goto finish;</span><br><span class="line"></span><br><span class="line">                if (reply) &#123;</span><br><span class="line">                    if ((tr.flags &amp; TF_STATUS_CODE) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        reply-&gt;ipcSetDataReference(</span><br><span class="line">                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size&#x2F;sizeof(binder_size_t),</span><br><span class="line">                            freeBuffer, this);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        err &#x3D; *reinterpret_cast&lt;const status_t*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        freeBuffer(NULL,</span><br><span class="line">                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size&#x2F;sizeof(binder_size_t), this);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    freeBuffer(NULL,</span><br><span class="line">                        reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size&#x2F;sizeof(binder_size_t), this);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            goto finish;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            err &#x3D; executeCommand(cmd);</span><br><span class="line">            if (err !&#x3D; NO_ERROR) goto finish;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    if (err !&#x3D; NO_ERROR) &#123;</span><br><span class="line">        if (acquireResult) *acquireResult &#x3D; err;</span><br><span class="line">        if (reply) reply-&gt;setError(err);</span><br><span class="line">        mLastError &#x3D; err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h5>2.3.2.2.1 IPCThreadState::talkWithDriver()</h5><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp *&#x2F;</span><br><span class="line">status_t IPCThreadState::talkWithDriver(bool doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    if (mProcess-&gt;mDriverFD &lt;&#x3D; 0) &#123;</span><br><span class="line">        return -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Is the read buffer empty?</span><br><span class="line">    const bool needRead &#x3D; mIn.dataPosition() &gt;&#x3D; mIn.dataSize();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We don&#39;t want to write anything if we are still reading</span><br><span class="line">    &#x2F;&#x2F; from data left in the input buffer and the caller</span><br><span class="line">    &#x2F;&#x2F; has requested to read the next data.</span><br><span class="line">    const size_t outAvail &#x3D; (!doReceive || needRead) ? mOut.dataSize() : 0;</span><br><span class="line"></span><br><span class="line">    bwr.write_size &#x3D; outAvail;</span><br><span class="line">    bwr.write_buffer &#x3D; (uintptr_t)mOut.data();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; This is what we&#39;ll read.</span><br><span class="line">    if (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size &#x3D; mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer &#x3D; (uintptr_t)mIn.data();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        bwr.read_size &#x3D; 0;</span><br><span class="line">        bwr.read_buffer &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IF_LOG_COMMANDS() &#123;</span><br><span class="line">        TextOutput::Bundle _b(alog);</span><br><span class="line">        if (outAvail !&#x3D; 0) &#123;</span><br><span class="line">            alog &lt;&lt; &quot;Sending commands to driver: &quot; &lt;&lt; indent;</span><br><span class="line">            const void* cmds &#x3D; (const void*)bwr.write_buffer;</span><br><span class="line">            const void* end &#x3D; ((const uint8_t*)cmds)+bwr.write_size;</span><br><span class="line">            alog &lt;&lt; HexDump(cmds, bwr.write_size) &lt;&lt; endl;</span><br><span class="line">            while (cmds &lt; end) cmds &#x3D; printCommand(alog, cmds);</span><br><span class="line">            alog &lt;&lt; dedent;</span><br><span class="line">        &#125;</span><br><span class="line">        alog &lt;&lt; &quot;Size of receive buffer: &quot; &lt;&lt; bwr.read_size</span><br><span class="line">            &lt;&lt; &quot;, needRead: &quot; &lt;&lt; needRead &lt;&lt; &quot;, doReceive: &quot; &lt;&lt; doReceive &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Return immediately if there is nothing to do.</span><br><span class="line">    if ((bwr.write_size &#x3D;&#x3D; 0) &amp;&amp; (bwr.read_size &#x3D;&#x3D; 0)) return NO_ERROR;</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed &#x3D; 0;</span><br><span class="line">    bwr.read_consumed &#x3D; 0;</span><br><span class="line">    status_t err;</span><br><span class="line">    do &#123;</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; &quot;About to read&#x2F;write, write size &#x3D; &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">#if defined(__ANDROID__)</span><br><span class="line">        &#x2F;&#x2F; 通过ioctl方法与Binder驱动进行通信(读写操作,这里是读)</span><br><span class="line">        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;&#x3D; 0)</span><br><span class="line">            err &#x3D; NO_ERROR;</span><br><span class="line">        else</span><br><span class="line">            err &#x3D; -errno;</span><br><span class="line">#else</span><br><span class="line">        err &#x3D; INVALID_OPERATION;</span><br><span class="line">#endif</span><br><span class="line">        if (mProcess-&gt;mDriverFD &lt;&#x3D; 0) &#123;</span><br><span class="line">            err &#x3D; -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; &quot;Finished read&#x2F;write, write size &#x3D; &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (err &#x3D;&#x3D; -EINTR);</span><br><span class="line"></span><br><span class="line">    IF_LOG_COMMANDS() &#123;</span><br><span class="line">        alog &lt;&lt; &quot;Our err: &quot; &lt;&lt; (void*)(intptr_t)err &lt;&lt; &quot;, write consumed: &quot;</span><br><span class="line">            &lt;&lt; bwr.write_consumed &lt;&lt; &quot; (of &quot; &lt;&lt; mOut.dataSize()</span><br><span class="line">                        &lt;&lt; &quot;), read consumed: &quot; &lt;&lt; bwr.read_consumed &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (err &gt;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        if (bwr.write_consumed &gt; 0) &#123;</span><br><span class="line">            if (bwr.write_consumed &lt; mOut.dataSize())</span><br><span class="line">                mOut.remove(0, bwr.write_consumed);</span><br><span class="line">            else &#123;</span><br><span class="line">                mOut.setDataSize(0);</span><br><span class="line">                processPostWriteDerefs();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (bwr.read_consumed &gt; 0) &#123;</span><br><span class="line">            mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">            mIn.setDataPosition(0);</span><br><span class="line">        &#125;</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            TextOutput::Bundle _b(alog);</span><br><span class="line">            alog &lt;&lt; &quot;Remaining data size: &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;</span><br><span class="line">            alog &lt;&lt; &quot;Received commands from driver: &quot; &lt;&lt; indent;</span><br><span class="line">            const void* cmds &#x3D; mIn.data();</span><br><span class="line">            const void* end &#x3D; mIn.data() + mIn.dataSize();</span><br><span class="line">            alog &lt;&lt; HexDump(cmds, mIn.dataSize()) &lt;&lt; endl;</span><br><span class="line">            while (cmds &lt; end) cmds &#x3D; printReturnCommand(alog, cmds);</span><br><span class="line">            alog &lt;&lt; dedent;</span><br><span class="line">        &#125;</span><br><span class="line">        return NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h5>2.3.2.2.2 IPCThreadState::executeCommand()</h5><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    status_t result &#x3D; NO_ERROR;</span><br><span class="line"></span><br><span class="line">    switch ((uint32_t)cmd) &#123;</span><br><span class="line">    case BR_ERROR:</span><br><span class="line">        result &#x3D; mIn.readInt32();</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_OK:</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_ACQUIRE:</span><br><span class="line">        refs &#x3D; (RefBase::weakref_type*)mIn.readPointer();</span><br><span class="line">        obj &#x3D; (BBinder*)mIn.readPointer();</span><br><span class="line">        ALOG_ASSERT(refs-&gt;refBase() &#x3D;&#x3D; obj,</span><br><span class="line">                   &quot;BR_ACQUIRE: object %p does not match cookie %p (expected %p)&quot;,</span><br><span class="line">                   refs, obj, refs-&gt;refBase());</span><br><span class="line">        obj-&gt;incStrong(mProcess.get());</span><br><span class="line">        IF_LOG_REMOTEREFS() &#123;</span><br><span class="line">            LOG_REMOTEREFS(&quot;BR_ACQUIRE from driver on %p&quot;, obj);</span><br><span class="line">            obj-&gt;printRefs();</span><br><span class="line">        &#125;</span><br><span class="line">        mOut.writeInt32(BC_ACQUIRE_DONE);</span><br><span class="line">        mOut.writePointer((uintptr_t)refs);</span><br><span class="line">        mOut.writePointer((uintptr_t)obj);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_RELEASE:</span><br><span class="line">        refs &#x3D; (RefBase::weakref_type*)mIn.readPointer();</span><br><span class="line">        obj &#x3D; (BBinder*)mIn.readPointer();</span><br><span class="line">        ALOG_ASSERT(refs-&gt;refBase() &#x3D;&#x3D; obj,</span><br><span class="line">                   &quot;BR_RELEASE: object %p does not match cookie %p (expected %p)&quot;,</span><br><span class="line">                   refs, obj, refs-&gt;refBase());</span><br><span class="line">        IF_LOG_REMOTEREFS() &#123;</span><br><span class="line">            LOG_REMOTEREFS(&quot;BR_RELEASE from driver on %p&quot;, obj);</span><br><span class="line">            obj-&gt;printRefs();</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingStrongDerefs.push(obj);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_INCREFS:</span><br><span class="line">        refs &#x3D; (RefBase::weakref_type*)mIn.readPointer();</span><br><span class="line">        obj &#x3D; (BBinder*)mIn.readPointer();</span><br><span class="line">        refs-&gt;incWeak(mProcess.get());</span><br><span class="line">        mOut.writeInt32(BC_INCREFS_DONE);</span><br><span class="line">        mOut.writePointer((uintptr_t)refs);</span><br><span class="line">        mOut.writePointer((uintptr_t)obj);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_DECREFS:</span><br><span class="line">        refs &#x3D; (RefBase::weakref_type*)mIn.readPointer();</span><br><span class="line">        obj &#x3D; (BBinder*)mIn.readPointer();</span><br><span class="line">        &#x2F;&#x2F; NOTE: This assertion is not valid, because the object may no</span><br><span class="line">        &#x2F;&#x2F; longer exist (thus the (BBinder*)cast above resulting in a different</span><br><span class="line">        &#x2F;&#x2F; memory address).</span><br><span class="line">        &#x2F;&#x2F;ALOG_ASSERT(refs-&gt;refBase() &#x3D;&#x3D; obj,</span><br><span class="line">        &#x2F;&#x2F;           &quot;BR_DECREFS: object %p does not match cookie %p (expected %p)&quot;,</span><br><span class="line">        &#x2F;&#x2F;           refs, obj, refs-&gt;refBase());</span><br><span class="line">        mPendingWeakDerefs.push(refs);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_ATTEMPT_ACQUIRE:</span><br><span class="line">        refs &#x3D; (RefBase::weakref_type*)mIn.readPointer();</span><br><span class="line">        obj &#x3D; (BBinder*)mIn.readPointer();</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            const bool success &#x3D; refs-&gt;attemptIncStrong(mProcess.get());</span><br><span class="line">            ALOG_ASSERT(success &amp;&amp; refs-&gt;refBase() &#x3D;&#x3D; obj,</span><br><span class="line">                       &quot;BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)&quot;,</span><br><span class="line">                       refs, obj, refs-&gt;refBase());</span><br><span class="line"></span><br><span class="line">            mOut.writeInt32(BC_ACQUIRE_RESULT);</span><br><span class="line">            mOut.writeInt32((int32_t)success);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            result &#x3D; mIn.read(&amp;tr, sizeof(tr));</span><br><span class="line">            ALOG_ASSERT(result &#x3D;&#x3D; NO_ERROR,</span><br><span class="line">                &quot;Not enough command data for brTRANSACTION&quot;);</span><br><span class="line">            if (result !&#x3D; NO_ERROR) break;</span><br><span class="line"></span><br><span class="line">            Parcel buffer;</span><br><span class="line">            buffer.ipcSetDataReference(</span><br><span class="line">                reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size&#x2F;sizeof(binder_size_t), freeBuffer, this);</span><br><span class="line"></span><br><span class="line">            const pid_t origPid &#x3D; mCallingPid;</span><br><span class="line">            const uid_t origUid &#x3D; mCallingUid;</span><br><span class="line">            const int32_t origStrictModePolicy &#x3D; mStrictModePolicy;</span><br><span class="line">            const int32_t origTransactionBinderFlags &#x3D; mLastTransactionBinderFlags;</span><br><span class="line"></span><br><span class="line">            mCallingPid &#x3D; tr.sender_pid;</span><br><span class="line">            mCallingUid &#x3D; tr.sender_euid;</span><br><span class="line">            mLastTransactionBinderFlags &#x3D; tr.flags;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;ALOGI(&quot;&gt;&gt;&gt;&gt; TRANSACT from pid %d uid %d\n&quot;, mCallingPid, mCallingUid);</span><br><span class="line"></span><br><span class="line">            Parcel reply;</span><br><span class="line">            status_t error;</span><br><span class="line">            IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; &quot;BR_TRANSACTION thr &quot; &lt;&lt; (void*)pthread_self()</span><br><span class="line">                    &lt;&lt; &quot; &#x2F; obj &quot; &lt;&lt; tr.target.ptr &lt;&lt; &quot; &#x2F; code &quot;</span><br><span class="line">                    &lt;&lt; TypeCode(tr.code) &lt;&lt; &quot;: &quot; &lt;&lt; indent &lt;&lt; buffer</span><br><span class="line">                    &lt;&lt; dedent &lt;&lt; endl</span><br><span class="line">                    &lt;&lt; &quot;Data addr &#x3D; &quot;</span><br><span class="line">                    &lt;&lt; reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer)</span><br><span class="line">                    &lt;&lt; &quot;, offsets addr&#x3D;&quot;</span><br><span class="line">                    &lt;&lt; reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            if (tr.target.ptr) &#123;</span><br><span class="line">                &#x2F;&#x2F; We only have a weak reference on the target object, so we must first try to</span><br><span class="line">                &#x2F;&#x2F; safely acquire a strong reference before doing anything else with it.</span><br><span class="line">                if (reinterpret_cast&lt;RefBase::weakref_type*&gt;(</span><br><span class="line">                        tr.target.ptr)-&gt;attemptIncStrong(this)) &#123;</span><br><span class="line">                    error &#x3D; reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer,</span><br><span class="line">                            &amp;reply, tr.flags);</span><br><span class="line">                    reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(this);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    error &#x3D; UNKNOWN_TRANSACTION;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                error &#x3D; the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;ALOGI(&quot;&lt;&lt;&lt;&lt; TRANSACT from pid %d restore pid %d uid %d\n&quot;,</span><br><span class="line">            &#x2F;&#x2F;     mCallingPid, origPid, origUid);</span><br><span class="line"></span><br><span class="line">            if ((tr.flags &amp; TF_ONE_WAY) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                LOG_ONEWAY(&quot;Sending reply to %d!&quot;, mCallingPid);</span><br><span class="line">                if (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">                sendReply(reply, 0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                LOG_ONEWAY(&quot;NOT sending reply to %d!&quot;, mCallingPid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mCallingPid &#x3D; origPid;</span><br><span class="line">            mCallingUid &#x3D; origUid;</span><br><span class="line">            mStrictModePolicy &#x3D; origStrictModePolicy;</span><br><span class="line">            mLastTransactionBinderFlags &#x3D; origTransactionBinderFlags;</span><br><span class="line"></span><br><span class="line">            IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; &quot;BC_REPLY thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; &#x2F; obj &quot;</span><br><span class="line">                    &lt;&lt; tr.target.ptr &lt;&lt; &quot;: &quot; &lt;&lt; indent &lt;&lt; reply &lt;&lt; dedent &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_DEAD_BINDER:</span><br><span class="line">        &#123;</span><br><span class="line">            BpBinder *proxy &#x3D; (BpBinder*)mIn.readPointer();</span><br><span class="line">            proxy-&gt;sendObituary();</span><br><span class="line">            mOut.writeInt32(BC_DEAD_BINDER_DONE);</span><br><span class="line">            mOut.writePointer((uintptr_t)proxy);</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">    case BR_CLEAR_DEATH_NOTIFICATION_DONE:</span><br><span class="line">        &#123;</span><br><span class="line">            BpBinder *proxy &#x3D; (BpBinder*)mIn.readPointer();</span><br><span class="line">            proxy-&gt;getWeakRefs()-&gt;decWeak(proxy);</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">    case BR_FINISHED:</span><br><span class="line">        result &#x3D; TIMED_OUT;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_NOOP:</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_SPAWN_LOOPER:</span><br><span class="line">        mProcess-&gt;spawnPooledThread(false);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        ALOGE(&quot;*** BAD COMMAND %d received from Binder driver\n&quot;, cmd);</span><br><span class="line">        result &#x3D; UNKNOWN_ERROR;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (result !&#x3D; NO_ERROR) &#123;</span><br><span class="line">        mLastError &#x3D; result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/guaong" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2020 Guaong<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>