<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="前言：笔记根据《深入理解android内核设计思想》记录

大致类似TCP/IP网络,如图:


1 Binder驱动任务
Binder驱动主要做三件事:
1.1 binder_open()
binder_open()的工作是打开/dev/binder节点,生成一个proc对象,初始化后的proc加"/>
    

    <!--Author-->
    
        <meta name="author" content="Guaong"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Android进程间通信Binder"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="前言：笔记根据《深入理解android内核设计思想》记录

大致类似TCP/IP网络,如图:


1 Binder驱动任务
Binder驱动主要做三件事:
1.1 binder_open()
binder_open()的工作是打开/dev/binder节点,生成一个proc对象,初始化后的proc加"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="Guaong"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="http://guaong.github.io/guaong.github.iohttps://i.loli.net/2020/02/07/WyfPYiuTQZneb5N.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="http://guaong.github.io/guaong.github.iohttps://i.loli.net/2020/02/07/WyfPYiuTQZneb5N.jpg"/>
    

    <!-- Title -->
    
    <title>Android进程间通信Binder - Guaong</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/guaong.github.io/css/style.css">


    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet"/>

    <!-- Google Analytics -->
    


    <!-- favicon -->
    

<meta name="generator" content="Hexo 4.2.0"></head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/guaong.github.io/">Configurable Title</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/guaong.github.io/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/guaong.github.io/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/guaong.github.io/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/guaong.github.io/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/guaong" target="_blank" rel="noopener">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('https://i.loli.net/2020/02/07/WyfPYiuTQZneb5N.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Android进程间通信Binder</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2020-02-02
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/guaong.github.io/tags/Android/">#Android</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <p>前言：笔记根据《深入理解android内核设计思想》记录<br></p>
<hr>
大致类似TCP/IP网络,如图:

<p><img src="https://guaong.github.io/guaong.github.io/2020/02/02/Android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1Binder/02.png" alt="流程"><br><br></p>
<h1>1 Binder驱动任务</h1><br>
Binder驱动主要做三件事:<br>
<h2>1.1 binder_open()</h2><br>
binder_open()的工作是打开/dev/binder节点,生成一个proc对象,初始化后的proc加入Binder的全局管理中<br>
<h2>1.2 binder_mmap()</h2><br>

<p><img src="https://guaong.github.io/guaong.github.io/2020/02/02/Android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1Binder/01.png" alt="流程"></p>
<h2>1.3 binder_ioctl()</h2><br>
用于向Binder读或写数据,获取Binder版本号等操作<br>
<h1>2 ServiceManager</h1><br>
<h2>2.1 ServiceManager启动</h2><br>
发生在init.rc中,重启会导致其他系统服务一起重启(zygote, media, surfacefinger, drm)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">service servicemanager &#x2F;system&#x2F;bin&#x2F;servicemanager</span><br><span class="line">	class core</span><br><span class="line">	user system</span><br><span class="line">	group system</span><br><span class="line">	critical</span><br><span class="line">	onrestart restart zygote&#x2F;*(受精卵?!!!)*&#x2F;</span><br><span class="line">	onrestart restart media</span><br><span class="line">	onrestart restart surfacefinger</span><br><span class="line">	onrestart restart drm</span><br></pre></td></tr></table></figure>
<br>
<h2>2.2 ServiceManager构建</h2><br>
从/frameworks/native/cmds/servicemanager/service_manager.c的main()开始,执行了:1.binder_open();2.binder_become_context_manager();3.binder_loop()方法.

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;service_manager.c *&#x2F;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    struct binder_state *bs;</span><br><span class="line">    union selinux_callback cb;</span><br><span class="line">    char *driver;</span><br><span class="line"></span><br><span class="line">    if (argc &gt; 1) &#123;</span><br><span class="line">        driver &#x3D; argv[1];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        driver &#x3D; &quot;&#x2F;dev&#x2F;binder&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs &#x3D; binder_open(driver, 128*1024); &#x2F;&#x2F; 得到关于新binder的相关信息</span><br><span class="line">    if (!bs) &#123;</span><br><span class="line">#ifdef VENDORSERVICEMANAGER</span><br><span class="line">        ALOGW(&quot;failed to open binder driver %s\n&quot;, driver);</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            sleep(UINT_MAX);</span><br><span class="line">        &#125;</span><br><span class="line">#else</span><br><span class="line">        ALOGE(&quot;failed to open binder driver %s\n&quot;, driver);</span><br><span class="line">#endif</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (binder_become_context_manager(bs)) &#123; &#x2F;&#x2F; 将这个binder设置为manager</span><br><span class="line">        ALOGE(&quot;cannot become context manager (%s)\n&quot;, strerror(errno));</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cb.func_audit &#x3D; audit_callback;</span><br><span class="line">    selinux_set_callback(SELINUX_CB_AUDIT, cb);</span><br><span class="line">    cb.func_log &#x3D; selinux_log_callback;</span><br><span class="line">    selinux_set_callback(SELINUX_CB_LOG, cb);</span><br><span class="line"></span><br><span class="line">#ifdef VENDORSERVICEMANAGER</span><br><span class="line">    sehandle &#x3D; selinux_android_vendor_service_context_handle();</span><br><span class="line">#else</span><br><span class="line">    sehandle &#x3D; selinux_android_service_context_handle();</span><br><span class="line">#endif</span><br><span class="line">    selinux_status_open(true);</span><br><span class="line"></span><br><span class="line">    if (sehandle &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        ALOGE(&quot;SELinux: Failed to acquire sehandle. Aborting.\n&quot;);</span><br><span class="line">        abort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (getcon(&amp;service_manager_context) !&#x3D; 0) &#123;</span><br><span class="line">        ALOGE(&quot;SELinux: Failed to acquire service_manager context. Aborting.\n&quot;);</span><br><span class="line">        abort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    binder_loop(bs, svcmgr_handler); &#x2F;&#x2F; 循环等待</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3>2.2.1 binder_open()</h3><br>
首先执行binder_open()方法,首先先执行了open()方法打开Binder驱动节点,然后执行mmap()方法,作用在上面[1.Binder驱动]中提到.

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.c *&#x2F;</span><br><span class="line">struct binder_state</span><br><span class="line">&#123;</span><br><span class="line">    int fd;</span><br><span class="line">    void *mapped;</span><br><span class="line">    size_t mapsize;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.c *&#x2F;</span><br><span class="line">struct binder_state *binder_open(const char* driver, size_t mapsize)</span><br><span class="line">&#123;</span><br><span class="line">    struct binder_state *bs;</span><br><span class="line">    struct binder_version vers;</span><br><span class="line"></span><br><span class="line">    bs &#x3D; malloc(sizeof(*bs));</span><br><span class="line">    if (!bs) &#123;</span><br><span class="line">        errno &#x3D; ENOMEM;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;fd &#x3D; open(driver, O_RDWR | O_CLOEXEC); &#x2F;&#x2F; </span><br><span class="line">    if (bs-&gt;fd &lt; 0) &#123;</span><br><span class="line">        fprintf(stderr,&quot;binder: cannot open %s (%s)\n&quot;,</span><br><span class="line">                driver, strerror(errno));</span><br><span class="line">        goto fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((ioctl(bs-&gt;fd, BINDER_VERSION, &amp;vers) &#x3D;&#x3D; -1) || &#x2F;&#x2F; </span><br><span class="line">        (vers.protocol_version !&#x3D; BINDER_CURRENT_PROTOCOL_VERSION)) &#123;</span><br><span class="line">        fprintf(stderr,</span><br><span class="line">                &quot;binder: kernel driver version (%d) differs from user space version (%d)\n&quot;,</span><br><span class="line">                vers.protocol_version, BINDER_CURRENT_PROTOCOL_VERSION);</span><br><span class="line">        goto fail_open;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bs-&gt;mapsize &#x3D; mapsize;</span><br><span class="line">    bs-&gt;mapped &#x3D; mmap(NULL, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, 0); &#x2F;&#x2F; 在用户空间开辟一块mapsize的空间</span><br><span class="line">    if (bs-&gt;mapped &#x3D;&#x3D; MAP_FAILED) &#123;</span><br><span class="line">        fprintf(stderr,&quot;binder: cannot map device (%s)\n&quot;,</span><br><span class="line">                strerror(errno));</span><br><span class="line">        goto fail_map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return bs;</span><br><span class="line"></span><br><span class="line">fail_map:</span><br><span class="line">    close(bs-&gt;fd);</span><br><span class="line">fail_open:</span><br><span class="line">    free(bs);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3>2.2.2 binder_become_context_manager()</h3><br>
接着执行binder_become_context_manager()方法,可以看到直接通过ioctl(BINDER_SET_CONTEXT_MGR)方法设置为service管理者,从上面binder_open()的代码看,service manager唯一.

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.c *&#x2F;</span><br><span class="line">int binder_become_context_manager(struct binder_state *bs)</span><br><span class="line">&#123;</span><br><span class="line">    return ioctl(bs-&gt;fd, BINDER_SET_CONTEXT_MGR, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3>2.2.3 binder_loop()</h3><br>
最后执行binder_loop()方法,一直循环处理消息,执行ioctl(BINDER_WRITE_READ)和binder_parse()方法.需要做的就是回复消息或者是处理与service相关的工作,比如get,add,serviceList等,正是service manager需要做的事情.

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct binder_write_read暂缺</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.c *&#x2F;</span><br><span class="line">void binder_loop(struct binder_state *bs, binder_handler func)</span><br><span class="line">&#123;</span><br><span class="line">    int res;</span><br><span class="line">    struct binder_write_read bwr;</span><br><span class="line">    uint32_t readbuf[32];</span><br><span class="line"></span><br><span class="line">    bwr.write_size &#x3D; 0;</span><br><span class="line">    bwr.write_consumed &#x3D; 0;</span><br><span class="line">    bwr.write_buffer &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    readbuf[0] &#x3D; BC_ENTER_LOOPER;</span><br><span class="line">    binder_write(bs, readbuf, sizeof(uint32_t));</span><br><span class="line"></span><br><span class="line">    for (;;) &#123; &#x2F;&#x2F; 循环执行</span><br><span class="line">        bwr.read_size &#x3D; sizeof(readbuf);</span><br><span class="line">        bwr.read_consumed &#x3D; 0;</span><br><span class="line">        bwr.read_buffer &#x3D; (uintptr_t) readbuf;</span><br><span class="line"></span><br><span class="line">        res &#x3D; ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr); &#x2F;&#x2F; 拿取消息</span><br><span class="line"></span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            ALOGE(&quot;binder_loop: ioctl failed (%s)\n&quot;, strerror(errno));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res &#x3D; binder_parse(bs, 0, (uintptr_t) readbuf, bwr.read_consumed, func); &#x2F;&#x2F;解析</span><br><span class="line">        if (res &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            ALOGE(&quot;binder_loop: unexpected reply?!\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (res &lt; 0) &#123;</span><br><span class="line">            ALOGE(&quot;binder_loop: io error %d %s\n&quot;, res, strerror(errno));</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ioctl(BINDER_WRITE_READ)就是读写,主要看binder_parse()方法,该方法while分支中BR_TRANSACTION和BR_REPLY作为重点.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;binder.c *&#x2F;</span><br><span class="line">int binder_parse(struct binder_state *bs, struct binder_io *bio,</span><br><span class="line">                 uintptr_t ptr, size_t size, binder_handler func)</span><br><span class="line">&#123;</span><br><span class="line">    int r &#x3D; 1;</span><br><span class="line">    uintptr_t end &#x3D; ptr + (uintptr_t) size;</span><br><span class="line"></span><br><span class="line">    while (ptr &lt; end) &#123;</span><br><span class="line">        uint32_t cmd &#x3D; *(uint32_t *) ptr;</span><br><span class="line">        ptr +&#x3D; sizeof(uint32_t);</span><br><span class="line">#if TRACE</span><br><span class="line">        fprintf(stderr,&quot;%s:\n&quot;, cmd_name(cmd));</span><br><span class="line">#endif</span><br><span class="line">        switch(cmd) &#123;</span><br><span class="line">        case BR_NOOP:</span><br><span class="line">            break;</span><br><span class="line">        case BR_TRANSACTION_COMPLETE:</span><br><span class="line">            break;</span><br><span class="line">        case BR_INCREFS:</span><br><span class="line">        case BR_ACQUIRE:</span><br><span class="line">        case BR_RELEASE:</span><br><span class="line">        case BR_DECREFS:</span><br><span class="line">#if TRACE</span><br><span class="line">            fprintf(stderr,&quot;  %p, %p\n&quot;, (void *)ptr, (void *)(ptr + sizeof(void *)));</span><br><span class="line">#endif</span><br><span class="line">            ptr +&#x3D; sizeof(struct binder_ptr_cookie);</span><br><span class="line">            break;</span><br><span class="line">        case BR_TRANSACTION: &#123;</span><br><span class="line">            struct binder_transaction_data *txn &#x3D; (struct binder_transaction_data *) ptr;</span><br><span class="line">            if ((end - ptr) &lt; sizeof(*txn)) &#123;</span><br><span class="line">                ALOGE(&quot;parse: txn too small!\n&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            if (func) &#123; &#x2F;&#x2F;svcmgr_handler()函数</span><br><span class="line">                unsigned rdata[256&#x2F;4];</span><br><span class="line">                struct binder_io msg;</span><br><span class="line">                struct binder_io reply;</span><br><span class="line">                int res;</span><br><span class="line"></span><br><span class="line">                bio_init(&amp;reply, rdata, sizeof(rdata), 4);</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                res &#x3D; func(bs, txn, &amp;msg, &amp;reply); &#x2F;&#x2F;svcmgr_handler()函数</span><br><span class="line">                if (txn-&gt;flags &amp; TF_ONE_WAY) &#123;</span><br><span class="line">                    binder_free_buffer(bs, txn-&gt;data.ptr.buffer);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr +&#x3D; sizeof(*txn);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case BR_REPLY: &#123;</span><br><span class="line">            struct binder_transaction_data *txn &#x3D; (struct binder_transaction_data *) ptr;</span><br><span class="line">            if ((end - ptr) &lt; sizeof(*txn)) &#123;</span><br><span class="line">                ALOGE(&quot;parse: reply too small!\n&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            if (bio) &#123;</span><br><span class="line">                bio_init_from_txn(bio, txn);</span><br><span class="line">                bio &#x3D; 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;* todo FREE BUFFER *&#x2F;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr +&#x3D; sizeof(*txn);</span><br><span class="line">            r &#x3D; 0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case BR_DEAD_BINDER: &#123;</span><br><span class="line">            struct binder_death *death &#x3D; (struct binder_death *)(uintptr_t) *(binder_uintptr_t *)ptr;</span><br><span class="line">            ptr +&#x3D; sizeof(binder_uintptr_t);</span><br><span class="line">            death-&gt;func(bs, death-&gt;ptr);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case BR_FAILED_REPLY:</span><br><span class="line">            r &#x3D; -1;</span><br><span class="line">            break;</span><br><span class="line">        case BR_DEAD_REPLY:</span><br><span class="line">            r &#x3D; -1;</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            ALOGE(&quot;parse: OOPS %d\n&quot;, cmd);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看BR_TRANSACTION,首先执行了func()方法赋值给res(func()是svcmgr_handler()),该方法提供了SVC_MGR_GET_SERVICE,SVC_MGR_CHECK_SERVICE获得handler;SVC_MGR_ADD_SERVICE添加;SVC_MGR_LIST_SERVICES返回列表.无论哪个分支最终都会将reply回复.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;cmds&#x2F;servicemanager&#x2F;service_manager.c *&#x2F;</span><br><span class="line">int svcmgr_handler(struct binder_state *bs,</span><br><span class="line">                   struct binder_transaction_data *txn,</span><br><span class="line">                   struct binder_io *msg,</span><br><span class="line">                   struct binder_io *reply)</span><br><span class="line">&#123;</span><br><span class="line">    struct svcinfo *si;</span><br><span class="line">    uint16_t *s;</span><br><span class="line">    size_t len;</span><br><span class="line">    uint32_t handle;</span><br><span class="line">    uint32_t strict_policy;</span><br><span class="line">    int allow_isolated;</span><br><span class="line">    uint32_t dumpsys_priority;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;ALOGI(&quot;target&#x3D;%p code&#x3D;%d pid&#x3D;%d uid&#x3D;%d\n&quot;,</span><br><span class="line">    &#x2F;&#x2F;      (void*) txn-&gt;target.ptr, txn-&gt;code, txn-&gt;sender_pid, txn-&gt;sender_euid);</span><br><span class="line"></span><br><span class="line">    if (txn-&gt;target.ptr !&#x3D; BINDER_SERVICE_MANAGER)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    if (txn-&gt;code &#x3D;&#x3D; PING_TRANSACTION)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Equivalent to Parcel::enforceInterface(), reading the RPC</span><br><span class="line">    &#x2F;&#x2F; header with the strict mode policy mask and the interface name.</span><br><span class="line">    &#x2F;&#x2F; Note that we ignore the strict_policy and don&#39;t propagate it</span><br><span class="line">    &#x2F;&#x2F; further (since we do no outbound RPCs anyway).</span><br><span class="line">    strict_policy &#x3D; bio_get_uint32(msg);</span><br><span class="line">    s &#x3D; bio_get_string16(msg, &amp;len);</span><br><span class="line">    if (s &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((len !&#x3D; (sizeof(svcmgr_id) &#x2F; 2)) ||</span><br><span class="line">        memcmp(svcmgr_id, s, sizeof(svcmgr_id))) &#123;</span><br><span class="line">        fprintf(stderr,&quot;invalid id %s\n&quot;, str8(s, len));</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (sehandle &amp;&amp; selinux_status_updated() &gt; 0) &#123;</span><br><span class="line">#ifdef VENDORSERVICEMANAGER</span><br><span class="line">        struct selabel_handle *tmp_sehandle &#x3D; selinux_android_vendor_service_context_handle();</span><br><span class="line">#else</span><br><span class="line">        struct selabel_handle *tmp_sehandle &#x3D; selinux_android_service_context_handle();</span><br><span class="line">#endif</span><br><span class="line">        if (tmp_sehandle) &#123;</span><br><span class="line">            selabel_close(sehandle);</span><br><span class="line">            sehandle &#x3D; tmp_sehandle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch(txn-&gt;code) &#123;</span><br><span class="line">    case SVC_MGR_GET_SERVICE:</span><br><span class="line">    case SVC_MGR_CHECK_SERVICE:</span><br><span class="line">        s &#x3D; bio_get_string16(msg, &amp;len);</span><br><span class="line">        if (s &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        handle &#x3D; do_find_service(s, len, txn-&gt;sender_euid, txn-&gt;sender_pid);</span><br><span class="line">        if (!handle)</span><br><span class="line">            break;</span><br><span class="line">        bio_put_ref(reply, handle);</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line">    case SVC_MGR_ADD_SERVICE:</span><br><span class="line">        s &#x3D; bio_get_string16(msg, &amp;len);</span><br><span class="line">        if (s &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        handle &#x3D; bio_get_ref(msg);</span><br><span class="line">        allow_isolated &#x3D; bio_get_uint32(msg) ? 1 : 0;</span><br><span class="line">        dumpsys_priority &#x3D; bio_get_uint32(msg);</span><br><span class="line">        if (do_add_service(bs, s, len, handle, txn-&gt;sender_euid, allow_isolated, dumpsys_priority,</span><br><span class="line">                           txn-&gt;sender_pid))</span><br><span class="line">            return -1;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case SVC_MGR_LIST_SERVICES: &#123;</span><br><span class="line">        uint32_t n &#x3D; bio_get_uint32(msg);</span><br><span class="line">        uint32_t req_dumpsys_priority &#x3D; bio_get_uint32(msg);</span><br><span class="line"></span><br><span class="line">        if (!svc_can_list(txn-&gt;sender_pid, txn-&gt;sender_euid)) &#123;</span><br><span class="line">            ALOGE(&quot;list_service() uid&#x3D;%d - PERMISSION DENIED\n&quot;,</span><br><span class="line">                    txn-&gt;sender_euid);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        si &#x3D; svclist;</span><br><span class="line">        &#x2F;&#x2F; walk through the list of services n times skipping services that</span><br><span class="line">        &#x2F;&#x2F; do not support the requested priority</span><br><span class="line">        while (si) &#123;</span><br><span class="line">            if (si-&gt;dumpsys_priority &amp; req_dumpsys_priority) &#123;</span><br><span class="line">                if (n &#x3D;&#x3D; 0) break;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            si &#x3D; si-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (si) &#123;</span><br><span class="line">            bio_put_string16(reply, si-&gt;name);</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    default:</span><br><span class="line">        ALOGE(&quot;unknown code %d\n&quot;, txn-&gt;code);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bio_put_uint32(reply, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再回过头看BR_REPLY, 根据书上所说,该分支并没有实质动作,因为SM没有向其他Binder Server主动发起请求的情况.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">case BR_REPLY: &#123;</span><br><span class="line">            struct binder_transaction_data *txn &#x3D; (struct binder_transaction_data *) ptr;</span><br><span class="line">            if ((end - ptr) &lt; sizeof(*txn)) &#123;</span><br><span class="line">                ALOGE(&quot;parse: reply too small!\n&quot;);</span><br><span class="line">                return -1;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            if (bio) &#123;</span><br><span class="line">                bio_init_from_txn(bio, txn);</span><br><span class="line">                bio &#x3D; 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;* todo FREE BUFFER *&#x2F;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr +&#x3D; sizeof(*txn);</span><br><span class="line">            r &#x3D; 0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<br>
具体流程如图:

<p><img src="https://guaong.github.io/guaong.github.io/2020/02/02/Android%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1Binder/03.png" alt="流程"><br><br></p>
<h2>2.3 获取ServiceManager服务</h2><br>
客户端Binder会通过getService()方法从SM中获得一个IBinder.下面三段代码中最重要的就是第三段rawGetService()中执行的getIServiceManager().getService(name)这行代码,这行代码分为两个部分:1.getIServiceManager();2.getService().

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public final class ServiceManager &#123;</span><br><span class="line">    public static IBinder getService(String name) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            IBinder service &#x3D; sCache.get(name);</span><br><span class="line">            if (service !&#x3D; null) &#123;</span><br><span class="line">                return service;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return Binder.allowBlocking(rawGetService(name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, &quot;error in getService&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Binder implements IBinder &#123;</span><br><span class="line">    public static IBinder allowBlocking(IBinder binder) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (binder instanceof BinderProxy) &#123;</span><br><span class="line">                ((BinderProxy) binder).mWarnOnBlocking &#x3D; false;</span><br><span class="line">            &#125; else if (binder !&#x3D; null &amp;&amp; binder.getInterfaceDescriptor() !&#x3D; null</span><br><span class="line">                    &amp;&amp; binder.queryLocalInterface(binder.getInterfaceDescriptor()) &#x3D;&#x3D; null) &#123;</span><br><span class="line">                Log.w(TAG, &quot;Unable to allow blocking on interface &quot; + binder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (RemoteException ignored) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        return binder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public final class ServiceManager &#123;</span><br><span class="line">    private static IBinder rawGetService(String name) throws RemoteException &#123;</span><br><span class="line">        final long start &#x3D; sStatLogger.getTime();</span><br><span class="line"></span><br><span class="line">        final IBinder binder &#x3D; getIServiceManager().getService(name);</span><br><span class="line"></span><br><span class="line">        final int time &#x3D; (int) sStatLogger.logDurationStat(Stats.GET_SERVICE, start);</span><br><span class="line"></span><br><span class="line">        final int myUid &#x3D; Process.myUid();</span><br><span class="line">        final boolean isCore &#x3D; UserHandle.isCore(myUid);</span><br><span class="line"></span><br><span class="line">        final long slowThreshold &#x3D; isCore</span><br><span class="line">                ? GET_SERVICE_SLOW_THRESHOLD_US_CORE</span><br><span class="line">                : GET_SERVICE_SLOW_THRESHOLD_US_NON_CORE;</span><br><span class="line"></span><br><span class="line">        synchronized (sLock) &#123;</span><br><span class="line">            sGetServiceAccumulatedUs +&#x3D; time;</span><br><span class="line">            sGetServiceAccumulatedCallCount++;</span><br><span class="line"></span><br><span class="line">            final long nowUptime &#x3D; SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Was a slow call?</span><br><span class="line">            if (time &gt;&#x3D; slowThreshold) &#123;</span><br><span class="line">                &#x2F;&#x2F; We do a slow log:</span><br><span class="line">                &#x2F;&#x2F; - At most once in every SLOW_LOG_INTERVAL_MS</span><br><span class="line">                &#x2F;&#x2F; - OR it was slower than the previously logged slow call.</span><br><span class="line">                if ((nowUptime &gt; (sLastSlowLogUptime + SLOW_LOG_INTERVAL_MS))</span><br><span class="line">                        || (sLastSlowLogActualTime &lt; time)) &#123;</span><br><span class="line">                    EventLogTags.writeServiceManagerSlow(time &#x2F; 1000, name);</span><br><span class="line"></span><br><span class="line">                    sLastSlowLogUptime &#x3D; nowUptime;</span><br><span class="line">                    sLastSlowLogActualTime &#x3D; time;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; Every GET_SERVICE_LOG_EVERY_CALLS calls, log the total time spent in getService().</span><br><span class="line"></span><br><span class="line">            final int logInterval &#x3D; isCore</span><br><span class="line">                    ? GET_SERVICE_LOG_EVERY_CALLS_CORE</span><br><span class="line">                    : GET_SERVICE_LOG_EVERY_CALLS_NON_CORE;</span><br><span class="line"></span><br><span class="line">            if ((sGetServiceAccumulatedCallCount &gt;&#x3D; logInterval)</span><br><span class="line">                    &amp;&amp; (nowUptime &gt;&#x3D; (sLastStatsLogUptime + STATS_LOG_INTERVAL_MS))) &#123;</span><br><span class="line"></span><br><span class="line">                EventLogTags.writeServiceManagerStats(</span><br><span class="line">                        sGetServiceAccumulatedCallCount, &#x2F;&#x2F; Total # of getService() calls.</span><br><span class="line">                        sGetServiceAccumulatedUs &#x2F; 1000, &#x2F;&#x2F; Total time spent in getService() calls.</span><br><span class="line">                        (int) (nowUptime - sLastStatsLogUptime)); &#x2F;&#x2F; Uptime duration since last log.</span><br><span class="line">                sGetServiceAccumulatedCallCount &#x3D; 0;</span><br><span class="line">                sGetServiceAccumulatedUs &#x3D; 0;</span><br><span class="line">                sLastStatsLogUptime &#x3D; nowUptime;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return binder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3>2.3.1 getIServiceManager()</h3><br>
首先先看getIServiceManager()方法.在该方法中主要看ServiceManagerNative.
asInterface(Binder.allowBlocking(BinderInternal.getContextObject()))这行代码,这行代码分为两块:1.asInterface();2.getContextObject().

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class ServiceManager &#123;</span><br><span class="line">    private static IServiceManager getIServiceManager() &#123;</span><br><span class="line">        if (sServiceManager !&#x3D; null) &#123;</span><br><span class="line">            return sServiceManager;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Find the service manager</span><br><span class="line">        sServiceManager &#x3D; ServiceManagerNative</span><br><span class="line">                .asInterface(Binder.allowBlocking(BinderInternal.getContextObject()));</span><br><span class="line">        return sServiceManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h4>2.3.1.1 getContextObject()</h4><br>
在研究asInterface()方法之前,先分析getContextObject()方法向asInterface()方法中传递的什么对象.(ps.代码很多)
可以看到该方法调用的时native层的getContextObject()方法.

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BinderInternal &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Return the global &quot;context object&quot; of the system.  This is usually</span><br><span class="line">     * an implementation of IServiceManager, which you can use to find</span><br><span class="line">     * other services.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    public static final native IBinder getContextObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据native层的android_os_util_BinderInternal_getContextObject()可以看到该方法可分为三步:1.new一个ProcessState;2.调用getContextObject();3.javaObjectForIBinder().</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;android_util_Binder.cpp *&#x2F;</span><br><span class="line">static jobject android_os_util_BinderInternal_getContextObject(JNIEnv* env, jobject clazz)&#123;</span><br><span class="line">    sp&lt;IBinder&gt; b &#x3D; ProcessState::self()-&gt;getContextObject(NULL);</span><br><span class="line">    return javaObjectForIBinder(env, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h5>2.3.1.1.1 ProcessState::self()</h5><br>
首先先看new一个ProcessState.根据构造方法代码可以看到ProcessState对象gProcess只能有一个,在没有该对象时要实例化一个对象.

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;ProcessState.cpp *&#x2F;</span><br><span class="line">sp&lt;ProcessState&gt; ProcessState::self()</span><br><span class="line">&#123;</span><br><span class="line">    Mutex::Autolock _l(gProcessMutex);</span><br><span class="line">    if (gProcess !&#x3D; NULL) &#123;</span><br><span class="line">        return gProcess;</span><br><span class="line">    &#125;</span><br><span class="line">    gProcess &#x3D; new ProcessState(&quot;&#x2F;dev&#x2F;binder&quot;);</span><br><span class="line">    return gProcess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实例化对象时,执行了open_driver()和mmap().和/frameworks/native/cmds/servicemanager/service_manager.c的main()执行的一样.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;ProcessState.cpp *&#x2F;</span><br><span class="line">ProcessState::ProcessState(const char *driver)</span><br><span class="line">    : mDriverName(String8(driver))</span><br><span class="line">    , mDriverFD(open_driver(driver))</span><br><span class="line">    , mVMStart(MAP_FAILED)</span><br><span class="line">    , mThreadCountLock(PTHREAD_MUTEX_INITIALIZER)</span><br><span class="line">    , mThreadCountDecrement(PTHREAD_COND_INITIALIZER)</span><br><span class="line">    , mExecutingThreadsCount(0)</span><br><span class="line">    , mMaxThreads(DEFAULT_MAX_BINDER_THREADS)</span><br><span class="line">    , mStarvationStartTimeMs(0)</span><br><span class="line">    , mManagesContexts(false)</span><br><span class="line">    , mBinderContextCheckFunc(NULL)</span><br><span class="line">    , mBinderContextUserData(NULL)</span><br><span class="line">    , mThreadPoolStarted(false)</span><br><span class="line">    , mThreadPoolSeq(1)</span><br><span class="line">&#123;</span><br><span class="line">    if (mDriverFD &gt;&#x3D; 0) &#123;</span><br><span class="line">        &#x2F;&#x2F; mmap the binder, providing a chunk of virtual address space to receive transactions.</span><br><span class="line">        mVMStart &#x3D; mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);</span><br><span class="line">        if (mVMStart &#x3D;&#x3D; MAP_FAILED) &#123;</span><br><span class="line">            &#x2F;&#x2F; *sigh*</span><br><span class="line">            ALOGE(&quot;Using %s failed: unable to mmap transaction memory.\n&quot;, mDriverName.c_str());</span><br><span class="line">            close(mDriverFD);</span><br><span class="line">            mDriverFD &#x3D; -1;</span><br><span class="line">            mDriverName.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_ALWAYS_FATAL_IF(mDriverFD &lt; 0, &quot;Binder driver could not be opened.  Terminating.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h5>2.3.1.1.2 getContextObject()</h5><br>
再看getContextObject(),实质是执行getStrongProxyForHandle()方法.

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;ProcessState.cpp *&#x2F;</span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getContextObject(const sp&lt;IBinder&gt;&amp; &#x2F;*caller*&#x2F;)</span><br><span class="line">&#123;</span><br><span class="line">    return getStrongProxyForHandle(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在getStrongProxyForHandle()方法中执行了BpBinder::create(handle);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;ProcessState.cpp *&#x2F;</span><br><span class="line">sp&lt;IBinder&gt; ProcessState::getStrongProxyForHandle(int32_t handle)</span><br><span class="line">&#123;</span><br><span class="line">    sp&lt;IBinder&gt; result;</span><br><span class="line"></span><br><span class="line">    AutoMutex _l(mLock);</span><br><span class="line"></span><br><span class="line">    handle_entry* e &#x3D; lookupHandleLocked(handle);</span><br><span class="line"></span><br><span class="line">    if (e !&#x3D; NULL) &#123;</span><br><span class="line">        &#x2F;&#x2F; We need to create a new BpBinder if there isn&#39;t currently one, OR we</span><br><span class="line">        &#x2F;&#x2F; are unable to acquire a weak reference on this current one.  See comment</span><br><span class="line">        &#x2F;&#x2F; in getWeakProxyForHandle() for more info about this.</span><br><span class="line">        IBinder* b &#x3D; e-&gt;binder;</span><br><span class="line">        if (b &#x3D;&#x3D; NULL || !e-&gt;refs-&gt;attemptIncWeak(this)) &#123;</span><br><span class="line">            if (handle &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                &#x2F;&#x2F; Special case for context manager...</span><br><span class="line">                &#x2F;&#x2F; The context manager is the only object for which we create</span><br><span class="line">                &#x2F;&#x2F; a BpBinder proxy without already holding a reference.</span><br><span class="line">                &#x2F;&#x2F; Perform a dummy transaction to ensure the context manager</span><br><span class="line">                &#x2F;&#x2F; is registered before we create the first local reference</span><br><span class="line">                &#x2F;&#x2F; to it (which will occur when creating the BpBinder).</span><br><span class="line">                &#x2F;&#x2F; If a local reference is created for the BpBinder when the</span><br><span class="line">                &#x2F;&#x2F; context manager is not present, the driver will fail to</span><br><span class="line">                &#x2F;&#x2F; provide a reference to the context manager, but the</span><br><span class="line">                &#x2F;&#x2F; driver API does not return status.</span><br><span class="line">                &#x2F;&#x2F;</span><br><span class="line">                &#x2F;&#x2F; Note that this is not race-free if the context manager</span><br><span class="line">                &#x2F;&#x2F; dies while this code runs.</span><br><span class="line">                &#x2F;&#x2F;</span><br><span class="line">                &#x2F;&#x2F; TODO: add a driver API to wait for context manager, or</span><br><span class="line">                &#x2F;&#x2F; stop special casing handle 0 for context manager and add</span><br><span class="line">                &#x2F;&#x2F; a driver API to get a handle to the context manager with</span><br><span class="line">                &#x2F;&#x2F; proper reference counting.</span><br><span class="line"></span><br><span class="line">                Parcel data;</span><br><span class="line">                status_t status &#x3D; IPCThreadState::self()-&gt;transact(</span><br><span class="line">                        0, IBinder::PING_TRANSACTION, data, NULL, 0);</span><br><span class="line">                if (status &#x3D;&#x3D; DEAD_OBJECT)</span><br><span class="line">                   return NULL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            b &#x3D; BpBinder::create(handle);</span><br><span class="line">            e-&gt;binder &#x3D; b;</span><br><span class="line">            if (b) e-&gt;refs &#x3D; b-&gt;getWeakRefs();</span><br><span class="line">            result &#x3D; b;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; This little bit of nastyness is to allow us to add a primary</span><br><span class="line">            &#x2F;&#x2F; reference to the remote proxy when this team doesn&#39;t have one</span><br><span class="line">            &#x2F;&#x2F; but another team is sending the handle to us.</span><br><span class="line">            result.force_set(b);</span><br><span class="line">            e-&gt;refs-&gt;decWeak(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在create方法中返回了new BpBinder(handle, trackedUid).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;BpBinder.cpp *&#x2F;</span><br><span class="line">BpBinder* BpBinder::create(int32_t handle) &#123;</span><br><span class="line">    int32_t trackedUid &#x3D; -1;</span><br><span class="line">    if (sCountByUidEnabled) &#123;</span><br><span class="line">        trackedUid &#x3D; IPCThreadState::self()-&gt;getCallingUid();</span><br><span class="line">        AutoMutex _l(sTrackingLock);</span><br><span class="line">        uint32_t trackedValue &#x3D; sTrackingMap[trackedUid];</span><br><span class="line">        if (CC_UNLIKELY(trackedValue &amp; LIMIT_REACHED_MASK)) &#123;</span><br><span class="line">            if (sBinderProxyThrottleCreate) &#123;</span><br><span class="line">                return nullptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if ((trackedValue &amp; COUNTING_VALUE_MASK) &gt;&#x3D; sBinderProxyCountHighWatermark) &#123;</span><br><span class="line">                ALOGE(&quot;Too many binder proxy objects sent to uid %d from uid %d (%d proxies held)&quot;,</span><br><span class="line">                      getuid(), trackedUid, trackedValue);</span><br><span class="line">                sTrackingMap[trackedUid] |&#x3D; LIMIT_REACHED_MASK;</span><br><span class="line">                if (sLimitCallback) sLimitCallback(trackedUid);</span><br><span class="line">                if (sBinderProxyThrottleCreate) &#123;</span><br><span class="line">                    ALOGI(&quot;Throttling binder proxy creates from uid %d in uid %d until binder proxy&quot;</span><br><span class="line">                          &quot; count drops below %d&quot;,</span><br><span class="line">                          trackedUid, getuid(), sBinderProxyCountLowWatermark);</span><br><span class="line">                    return nullptr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sTrackingMap[trackedUid]++;</span><br><span class="line">    &#125;</span><br><span class="line">    return new BpBinder(handle, trackedUid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* &#x2F;frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;BpBinder.cpp *&#x2F;</span><br><span class="line">BpBinder::BpBinder(int32_t handle, int32_t trackedUid)</span><br><span class="line">    : mHandle(handle)</span><br><span class="line">    , mAlive(1)</span><br><span class="line">    , mObitsSent(0)</span><br><span class="line">    , mObituaries(NULL)</span><br><span class="line">    , mTrackedUid(trackedUid)</span><br><span class="line">&#123;</span><br><span class="line">    ALOGV(&quot;Creating BpBinder %p handle %d\n&quot;, this, mHandle);</span><br><span class="line"></span><br><span class="line">    extendObjectLifetime(OBJECT_LIFETIME_WEAK);</span><br><span class="line">    IPCThreadState::self()-&gt;incWeakHandle(handle, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp *&#x2F;</span><br><span class="line">IPCThreadState* IPCThreadState::self()</span><br><span class="line">&#123;</span><br><span class="line">    if (gHaveTLS) &#123;</span><br><span class="line">restart:</span><br><span class="line">        const pthread_key_t k &#x3D; gTLS;</span><br><span class="line">        IPCThreadState* st &#x3D; (IPCThreadState*)pthread_getspecific(k);</span><br><span class="line">        if (st) return st;</span><br><span class="line">        return new IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (gShutdown) &#123;</span><br><span class="line">        ALOGW(&quot;Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line">    if (!gHaveTLS) &#123;</span><br><span class="line">        int key_create_value &#x3D; pthread_key_create(&amp;gTLS, threadDestructor);</span><br><span class="line">        if (key_create_value !&#x3D; 0) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">            ALOGW(&quot;IPCThreadState::self() unable to create TLS key, expect a crash: %s\n&quot;,</span><br><span class="line">                    strerror(key_create_value));</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        gHaveTLS &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">    goto restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp *&#x2F;</span><br><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">    : mProcess(ProcessState::self()),</span><br><span class="line">      mStrictModePolicy(0),</span><br><span class="line">      mLastTransactionBinderFlags(0)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_setspecific(gTLS, this);</span><br><span class="line">    clearCaller();</span><br><span class="line">    mIn.setDataCapacity(256);</span><br><span class="line">    mOut.setDataCapacity(256);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp *&#x2F;</span><br><span class="line">void IPCThreadState::incWeakHandle(int32_t handle, BpBinder *proxy)</span><br><span class="line">&#123;</span><br><span class="line">    LOG_REMOTEREFS(&quot;IPCThreadState::incWeakHandle(%d)\n&quot;, handle);</span><br><span class="line">    mOut.writeInt32(BC_INCREFS);</span><br><span class="line">    mOut.writeInt32(handle);</span><br><span class="line">    &#x2F;&#x2F; Create a temp reference until the driver has handled this command.</span><br><span class="line">    proxy-&gt;getWeakRefs()-&gt;incWeak(mProcess.get());</span><br><span class="line">    mPostWriteWeakDerefs.push(proxy-&gt;getWeakRefs());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h5>2.3.1.1.3 javaObjectForIBinder()</h5><br>
<br>
<h4>2.3.1.2 asInterface()</h4><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ServiceManagerNative extends Binder implements IServiceManager</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将Binder对象转换成IServiceManager if needed.或者创建一个ServiceManagerProxy对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static public IServiceManager asInterface(IBinder obj)</span><br><span class="line">    &#123;</span><br><span class="line">        if (obj &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        IServiceManager in &#x3D;</span><br><span class="line">            (IServiceManager)obj.queryLocalInterface(descriptor);</span><br><span class="line">        if (in !&#x3D; null) &#123;</span><br><span class="line">            return in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return new ServiceManagerProxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class ServiceManagerProxy implements IServiceManager &#123;</span><br><span class="line">    public ServiceManagerProxy(IBinder remote) &#123;</span><br><span class="line">        mRemote &#x3D; remote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h3>2.3.2 getService()</h3><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ServiceManagerProxy implements IServiceManager &#123;</span><br><span class="line">    public IBinder getService(String name) throws RemoteException &#123;</span><br><span class="line">        &#x2F;&#x2F;Parcel是消息的数据包</span><br><span class="line">        Parcel data &#x3D; Parcel.obtain();</span><br><span class="line">        Parcel reply &#x3D; Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IServiceManager.descriptor);</span><br><span class="line">        data.writeString(name);</span><br><span class="line">        mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0);</span><br><span class="line">        IBinder binder &#x3D; reply.readStrongBinder();</span><br><span class="line">        reply.recycle();</span><br><span class="line">        data.recycle();</span><br><span class="line">        return binder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class BinderProxy implements IBinder &#123;</span><br><span class="line">    public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123;</span><br><span class="line">        Binder.checkParcel(this, code, data, &quot;Unreasonably large binder buffer&quot;);</span><br><span class="line"></span><br><span class="line">        if (mWarnOnBlocking &amp;&amp; ((flags &amp; FLAG_ONEWAY) &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">            &#x2F;&#x2F; For now, avoid spamming the log by disabling after we&#39;ve logged</span><br><span class="line">            &#x2F;&#x2F; about this interface at least once</span><br><span class="line">            mWarnOnBlocking &#x3D; false;</span><br><span class="line">            Log.w(Binder.TAG, &quot;Outgoing transactions from this process must be FLAG_ONEWAY&quot;,</span><br><span class="line">                    new Throwable());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean tracingEnabled &#x3D; Binder.isTracingEnabled();</span><br><span class="line">        if (tracingEnabled) &#123;</span><br><span class="line">            final Throwable tr &#x3D; new Throwable();</span><br><span class="line">            Binder.getTransactionTracker().addTrace(tr);</span><br><span class="line">            StackTraceElement stackTraceElement &#x3D; tr.getStackTrace()[1];</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ALWAYS,</span><br><span class="line">                    stackTraceElement.getClassName() + &quot;.&quot; + stackTraceElement.getMethodName());</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            return transactNative(code, data, reply, flags);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (tracingEnabled) &#123;</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ALWAYS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class BinderProxy implements IBinder &#123;</span><br><span class="line">    public native boolean transactNative(int code, Parcel data, Parcel reply,</span><br><span class="line">            int flags) throws RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* android_util_Binder.cpp *&#x2F;</span><br><span class="line">&#x2F;&#x2F;与上面TransactNative()方法中间应该还有步骤,但是书上没有描述</span><br><span class="line">static jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,</span><br><span class="line">        jint code, jobject dataObj, jobject replyObj, jint flags) &#x2F;&#x2F; throws RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    if (dataObj &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        jniThrowNullPointerException(env, NULL);</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Parcel* data &#x3D; parcelForJavaObject(env, dataObj);</span><br><span class="line">    if (data &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    Parcel* reply &#x3D; parcelForJavaObject(env, replyObj);</span><br><span class="line">    if (reply &#x3D;&#x3D; NULL &amp;&amp; replyObj !&#x3D; NULL) &#123;</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IBinder* target &#x3D; getBPNativeData(env, obj)-&gt;mObject.get();</span><br><span class="line">    if (target &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        jniThrowException(env, &quot;java&#x2F;lang&#x2F;IllegalStateException&quot;, &quot;Binder has been finalized!&quot;);</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ALOGV(&quot;Java code calling transact on %p in Java object %p with code %&quot; PRId32 &quot;\n&quot;,</span><br><span class="line">            target, obj, code);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bool time_binder_calls;</span><br><span class="line">    int64_t start_millis;</span><br><span class="line">    if (kEnableBinderSample) &#123;</span><br><span class="line">        &#x2F;&#x2F; Only log the binder call duration for things on the Java-level main thread.</span><br><span class="line">        &#x2F;&#x2F; But if we don&#39;t</span><br><span class="line">        time_binder_calls &#x3D; should_time_binder_calls();</span><br><span class="line"></span><br><span class="line">        if (time_binder_calls) &#123;</span><br><span class="line">            start_millis &#x3D; uptimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;printf(&quot;Transact from Java code to %p sending: &quot;, target); data-&gt;print();</span><br><span class="line">    status_t err &#x3D; target-&gt;transact(code, *data, reply, flags);</span><br><span class="line">    &#x2F;&#x2F;if (reply) printf(&quot;Transact from Java code to %p received: &quot;, target); reply-&gt;print();</span><br><span class="line"></span><br><span class="line">    if (kEnableBinderSample) &#123;</span><br><span class="line">        if (time_binder_calls) &#123;</span><br><span class="line">            conditionally_log_binder_call(start_millis, target, code);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (err &#x3D;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        return JNI_TRUE;</span><br><span class="line">    &#125; else if (err &#x3D;&#x3D; UNKNOWN_TRANSACTION) &#123;</span><br><span class="line">        return JNI_FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signalExceptionForError(env, obj, err, true &#x2F;*canThrowRemoteException*&#x2F;, data-&gt;dataSize());</span><br><span class="line">    return JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行到BpBinder::transact()方法,该方法中分为两步:1.IPCThreadState::self();2.IPCThreadState::self()-&gt;transact(mHandle, code, data, reply, flags).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">status_t BpBinder::transact(</span><br><span class="line">    uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Once a binder has died, it will never come back to life.</span><br><span class="line">    if (mAlive) &#123;</span><br><span class="line">        status_t status &#x3D; IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        if (status &#x3D;&#x3D; DEAD_OBJECT) mAlive &#x3D; 0;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return DEAD_OBJECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h4>2.3.2.1 IPCThreadState::self()</h4><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp *&#x2F;</span><br><span class="line">IPCThreadState* IPCThreadState::self()</span><br><span class="line">&#123;</span><br><span class="line">    if (gHaveTLS) &#123;</span><br><span class="line">restart:</span><br><span class="line">        const pthread_key_t k &#x3D; gTLS;</span><br><span class="line">        IPCThreadState* st &#x3D; (IPCThreadState*)pthread_getspecific(k);</span><br><span class="line">        if (st) return st;</span><br><span class="line">        return new IPCThreadState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (gShutdown) &#123;</span><br><span class="line">        ALOGW(&quot;Calling IPCThreadState::self() during shutdown is dangerous, expect a crash.\n&quot;);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;gTLSMutex);</span><br><span class="line">    if (!gHaveTLS) &#123;</span><br><span class="line">        int key_create_value &#x3D; pthread_key_create(&amp;gTLS, threadDestructor);</span><br><span class="line">        if (key_create_value !&#x3D; 0) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">            ALOGW(&quot;IPCThreadState::self() unable to create TLS key, expect a crash: %s\n&quot;,</span><br><span class="line">                    strerror(key_create_value));</span><br><span class="line">            return NULL;</span><br><span class="line">        &#125;</span><br><span class="line">        gHaveTLS &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;gTLSMutex);</span><br><span class="line">    goto restart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp *&#x2F;</span><br><span class="line">IPCThreadState::IPCThreadState()</span><br><span class="line">    : mProcess(ProcessState::self()),</span><br><span class="line">      mStrictModePolicy(0),</span><br><span class="line">      mLastTransactionBinderFlags(0)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_setspecific(gTLS, this);</span><br><span class="line">    clearCaller();</span><br><span class="line">    mIn.setDataCapacity(256);</span><br><span class="line">    mOut.setDataCapacity(256);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h4>2.3.2.2 IPCThreadState::self()->transact()</h4><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp *&#x2F;</span><br><span class="line">status_t IPCThreadState::transact(int32_t handle,</span><br><span class="line">                                  uint32_t code, const Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, uint32_t flags)</span><br><span class="line">&#123;</span><br><span class="line">    status_t err;</span><br><span class="line"></span><br><span class="line">    flags |&#x3D; TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">        TextOutput::Bundle _b(alog);</span><br><span class="line">        alog &lt;&lt; &quot;BC_TRANSACTION thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; &#x2F; hand &quot;</span><br><span class="line">            &lt;&lt; handle &lt;&lt; &quot; &#x2F; code &quot; &lt;&lt; TypeCode(code) &lt;&lt; &quot;: &quot;</span><br><span class="line">            &lt;&lt; indent &lt;&lt; data &lt;&lt; dedent &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_ONEWAY(&quot;&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s&quot;, getpid(), getuid(),</span><br><span class="line">        (flags &amp; TF_ONE_WAY) &#x3D;&#x3D; 0 ? &quot;READ REPLY&quot; : &quot;ONE WAY&quot;);</span><br><span class="line">    err &#x3D; writeTransactionData(BC_TRANSACTION, flags, handle, code, data, NULL);</span><br><span class="line"></span><br><span class="line">    if (err !&#x3D; NO_ERROR) &#123;</span><br><span class="line">        if (reply) reply-&gt;setError(err);</span><br><span class="line">        return (mLastError &#x3D; err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if ((flags &amp; TF_ONE_WAY) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        #if 0</span><br><span class="line">        if (code &#x3D;&#x3D; 4) &#123; &#x2F;&#x2F; relayout</span><br><span class="line">            ALOGI(&quot;&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction 4&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ALOGI(&quot;&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction %d&quot;, code);</span><br><span class="line">        &#125;</span><br><span class="line">        #endif</span><br><span class="line">        if (reply) &#123;</span><br><span class="line">            err &#x3D; waitForResponse(reply);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err &#x3D; waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">        #if 0</span><br><span class="line">        if (code &#x3D;&#x3D; 4) &#123; &#x2F;&#x2F; relayout</span><br><span class="line">            ALOGI(&quot;&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction 4&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ALOGI(&quot;&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction %d&quot;, code);</span><br><span class="line">        &#125;</span><br><span class="line">        #endif</span><br><span class="line"></span><br><span class="line">        IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">            TextOutput::Bundle _b(alog);</span><br><span class="line">            alog &lt;&lt; &quot;BR_REPLY thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; &#x2F; hand &quot;</span><br><span class="line">                &lt;&lt; handle &lt;&lt; &quot;: &quot;;</span><br><span class="line">            if (reply) alog &lt;&lt; indent &lt;&lt; *reply &lt;&lt; dedent &lt;&lt; endl;</span><br><span class="line">            else alog &lt;&lt; &quot;(none requested)&quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        err &#x3D; waitForResponse(NULL, NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IPCThreadState::waitForResponse()方法分为两步:1.talkWithDriver();2.executeCommand().</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp *&#x2F;</span><br><span class="line">status_t IPCThreadState::waitForResponse(Parcel *reply, status_t *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t cmd;</span><br><span class="line">    int32_t err;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        if ((err&#x3D;talkWithDriver()) &lt; NO_ERROR) break;</span><br><span class="line">        err &#x3D; mIn.errorCheck();</span><br><span class="line">        if (err &lt; NO_ERROR) break;</span><br><span class="line">        if (mIn.dataAvail() &#x3D;&#x3D; 0) continue;</span><br><span class="line"></span><br><span class="line">        cmd &#x3D; (uint32_t)mIn.readInt32();</span><br><span class="line"></span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; &quot;Processing waitForResponse Command: &quot;</span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch (cmd) &#123;</span><br><span class="line">        case BR_TRANSACTION_COMPLETE:</span><br><span class="line">            if (!reply &amp;&amp; !acquireResult) goto finish;</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case BR_DEAD_REPLY:</span><br><span class="line">            err &#x3D; DEAD_OBJECT;</span><br><span class="line">            goto finish;</span><br><span class="line"></span><br><span class="line">        case BR_FAILED_REPLY:</span><br><span class="line">            err &#x3D; FAILED_TRANSACTION;</span><br><span class="line">            goto finish;</span><br><span class="line"></span><br><span class="line">        case BR_ACQUIRE_RESULT:</span><br><span class="line">            &#123;</span><br><span class="line">                ALOG_ASSERT(acquireResult !&#x3D; NULL, &quot;Unexpected brACQUIRE_RESULT&quot;);</span><br><span class="line">                const int32_t result &#x3D; mIn.readInt32();</span><br><span class="line">                if (!acquireResult) continue;</span><br><span class="line">                *acquireResult &#x3D; result ? NO_ERROR : INVALID_OPERATION;</span><br><span class="line">            &#125;</span><br><span class="line">            goto finish;</span><br><span class="line"></span><br><span class="line">        case BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err &#x3D; mIn.read(&amp;tr, sizeof(tr));</span><br><span class="line">                ALOG_ASSERT(err &#x3D;&#x3D; NO_ERROR, &quot;Not enough command data for brREPLY&quot;);</span><br><span class="line">                if (err !&#x3D; NO_ERROR) goto finish;</span><br><span class="line"></span><br><span class="line">                if (reply) &#123;</span><br><span class="line">                    if ((tr.flags &amp; TF_STATUS_CODE) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        reply-&gt;ipcSetDataReference(</span><br><span class="line">                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size&#x2F;sizeof(binder_size_t),</span><br><span class="line">                            freeBuffer, this);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        err &#x3D; *reinterpret_cast&lt;const status_t*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        freeBuffer(NULL,</span><br><span class="line">                            reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size&#x2F;sizeof(binder_size_t), this);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    freeBuffer(NULL,</span><br><span class="line">                        reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size&#x2F;sizeof(binder_size_t), this);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            goto finish;</span><br><span class="line"></span><br><span class="line">        default:</span><br><span class="line">            err &#x3D; executeCommand(cmd);</span><br><span class="line">            if (err !&#x3D; NO_ERROR) goto finish;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    if (err !&#x3D; NO_ERROR) &#123;</span><br><span class="line">        if (acquireResult) *acquireResult &#x3D; err;</span><br><span class="line">        if (reply) reply-&gt;setError(err);</span><br><span class="line">        mLastError &#x3D; err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h5>2.3.2.2.1 IPCThreadState::talkWithDriver()</h5><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* frameworks&#x2F;native&#x2F;libs&#x2F;binder&#x2F;IPCThreadState.cpp *&#x2F;</span><br><span class="line">status_t IPCThreadState::talkWithDriver(bool doReceive)</span><br><span class="line">&#123;</span><br><span class="line">    if (mProcess-&gt;mDriverFD &lt;&#x3D; 0) &#123;</span><br><span class="line">        return -EBADF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    binder_write_read bwr;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Is the read buffer empty?</span><br><span class="line">    const bool needRead &#x3D; mIn.dataPosition() &gt;&#x3D; mIn.dataSize();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; We don&#39;t want to write anything if we are still reading</span><br><span class="line">    &#x2F;&#x2F; from data left in the input buffer and the caller</span><br><span class="line">    &#x2F;&#x2F; has requested to read the next data.</span><br><span class="line">    const size_t outAvail &#x3D; (!doReceive || needRead) ? mOut.dataSize() : 0;</span><br><span class="line"></span><br><span class="line">    bwr.write_size &#x3D; outAvail;</span><br><span class="line">    bwr.write_buffer &#x3D; (uintptr_t)mOut.data();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; This is what we&#39;ll read.</span><br><span class="line">    if (doReceive &amp;&amp; needRead) &#123;</span><br><span class="line">        bwr.read_size &#x3D; mIn.dataCapacity();</span><br><span class="line">        bwr.read_buffer &#x3D; (uintptr_t)mIn.data();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        bwr.read_size &#x3D; 0;</span><br><span class="line">        bwr.read_buffer &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IF_LOG_COMMANDS() &#123;</span><br><span class="line">        TextOutput::Bundle _b(alog);</span><br><span class="line">        if (outAvail !&#x3D; 0) &#123;</span><br><span class="line">            alog &lt;&lt; &quot;Sending commands to driver: &quot; &lt;&lt; indent;</span><br><span class="line">            const void* cmds &#x3D; (const void*)bwr.write_buffer;</span><br><span class="line">            const void* end &#x3D; ((const uint8_t*)cmds)+bwr.write_size;</span><br><span class="line">            alog &lt;&lt; HexDump(cmds, bwr.write_size) &lt;&lt; endl;</span><br><span class="line">            while (cmds &lt; end) cmds &#x3D; printCommand(alog, cmds);</span><br><span class="line">            alog &lt;&lt; dedent;</span><br><span class="line">        &#125;</span><br><span class="line">        alog &lt;&lt; &quot;Size of receive buffer: &quot; &lt;&lt; bwr.read_size</span><br><span class="line">            &lt;&lt; &quot;, needRead: &quot; &lt;&lt; needRead &lt;&lt; &quot;, doReceive: &quot; &lt;&lt; doReceive &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Return immediately if there is nothing to do.</span><br><span class="line">    if ((bwr.write_size &#x3D;&#x3D; 0) &amp;&amp; (bwr.read_size &#x3D;&#x3D; 0)) return NO_ERROR;</span><br><span class="line"></span><br><span class="line">    bwr.write_consumed &#x3D; 0;</span><br><span class="line">    bwr.read_consumed &#x3D; 0;</span><br><span class="line">    status_t err;</span><br><span class="line">    do &#123;</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; &quot;About to read&#x2F;write, write size &#x3D; &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">#if defined(__ANDROID__)</span><br><span class="line">        if (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;&#x3D; 0)</span><br><span class="line">            err &#x3D; NO_ERROR;</span><br><span class="line">        else</span><br><span class="line">            err &#x3D; -errno;</span><br><span class="line">#else</span><br><span class="line">        err &#x3D; INVALID_OPERATION;</span><br><span class="line">#endif</span><br><span class="line">        if (mProcess-&gt;mDriverFD &lt;&#x3D; 0) &#123;</span><br><span class="line">            err &#x3D; -EBADF;</span><br><span class="line">        &#125;</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; &quot;Finished read&#x2F;write, write size &#x3D; &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; while (err &#x3D;&#x3D; -EINTR);</span><br><span class="line"></span><br><span class="line">    IF_LOG_COMMANDS() &#123;</span><br><span class="line">        alog &lt;&lt; &quot;Our err: &quot; &lt;&lt; (void*)(intptr_t)err &lt;&lt; &quot;, write consumed: &quot;</span><br><span class="line">            &lt;&lt; bwr.write_consumed &lt;&lt; &quot; (of &quot; &lt;&lt; mOut.dataSize()</span><br><span class="line">                        &lt;&lt; &quot;), read consumed: &quot; &lt;&lt; bwr.read_consumed &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (err &gt;&#x3D; NO_ERROR) &#123;</span><br><span class="line">        if (bwr.write_consumed &gt; 0) &#123;</span><br><span class="line">            if (bwr.write_consumed &lt; mOut.dataSize())</span><br><span class="line">                mOut.remove(0, bwr.write_consumed);</span><br><span class="line">            else &#123;</span><br><span class="line">                mOut.setDataSize(0);</span><br><span class="line">                processPostWriteDerefs();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (bwr.read_consumed &gt; 0) &#123;</span><br><span class="line">            mIn.setDataSize(bwr.read_consumed);</span><br><span class="line">            mIn.setDataPosition(0);</span><br><span class="line">        &#125;</span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            TextOutput::Bundle _b(alog);</span><br><span class="line">            alog &lt;&lt; &quot;Remaining data size: &quot; &lt;&lt; mOut.dataSize() &lt;&lt; endl;</span><br><span class="line">            alog &lt;&lt; &quot;Received commands from driver: &quot; &lt;&lt; indent;</span><br><span class="line">            const void* cmds &#x3D; mIn.data();</span><br><span class="line">            const void* end &#x3D; mIn.data() + mIn.dataSize();</span><br><span class="line">            alog &lt;&lt; HexDump(cmds, mIn.dataSize()) &lt;&lt; endl;</span><br><span class="line">            while (cmds &lt; end) cmds &#x3D; printReturnCommand(alog, cmds);</span><br><span class="line">            alog &lt;&lt; dedent;</span><br><span class="line">        &#125;</span><br><span class="line">        return NO_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br>
<h5>2.3.2.2.2 IPCThreadState::executeCommand()</h5><br>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line">status_t IPCThreadState::executeCommand(int32_t cmd)</span><br><span class="line">&#123;</span><br><span class="line">    BBinder* obj;</span><br><span class="line">    RefBase::weakref_type* refs;</span><br><span class="line">    status_t result &#x3D; NO_ERROR;</span><br><span class="line"></span><br><span class="line">    switch ((uint32_t)cmd) &#123;</span><br><span class="line">    case BR_ERROR:</span><br><span class="line">        result &#x3D; mIn.readInt32();</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_OK:</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_ACQUIRE:</span><br><span class="line">        refs &#x3D; (RefBase::weakref_type*)mIn.readPointer();</span><br><span class="line">        obj &#x3D; (BBinder*)mIn.readPointer();</span><br><span class="line">        ALOG_ASSERT(refs-&gt;refBase() &#x3D;&#x3D; obj,</span><br><span class="line">                   &quot;BR_ACQUIRE: object %p does not match cookie %p (expected %p)&quot;,</span><br><span class="line">                   refs, obj, refs-&gt;refBase());</span><br><span class="line">        obj-&gt;incStrong(mProcess.get());</span><br><span class="line">        IF_LOG_REMOTEREFS() &#123;</span><br><span class="line">            LOG_REMOTEREFS(&quot;BR_ACQUIRE from driver on %p&quot;, obj);</span><br><span class="line">            obj-&gt;printRefs();</span><br><span class="line">        &#125;</span><br><span class="line">        mOut.writeInt32(BC_ACQUIRE_DONE);</span><br><span class="line">        mOut.writePointer((uintptr_t)refs);</span><br><span class="line">        mOut.writePointer((uintptr_t)obj);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_RELEASE:</span><br><span class="line">        refs &#x3D; (RefBase::weakref_type*)mIn.readPointer();</span><br><span class="line">        obj &#x3D; (BBinder*)mIn.readPointer();</span><br><span class="line">        ALOG_ASSERT(refs-&gt;refBase() &#x3D;&#x3D; obj,</span><br><span class="line">                   &quot;BR_RELEASE: object %p does not match cookie %p (expected %p)&quot;,</span><br><span class="line">                   refs, obj, refs-&gt;refBase());</span><br><span class="line">        IF_LOG_REMOTEREFS() &#123;</span><br><span class="line">            LOG_REMOTEREFS(&quot;BR_RELEASE from driver on %p&quot;, obj);</span><br><span class="line">            obj-&gt;printRefs();</span><br><span class="line">        &#125;</span><br><span class="line">        mPendingStrongDerefs.push(obj);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_INCREFS:</span><br><span class="line">        refs &#x3D; (RefBase::weakref_type*)mIn.readPointer();</span><br><span class="line">        obj &#x3D; (BBinder*)mIn.readPointer();</span><br><span class="line">        refs-&gt;incWeak(mProcess.get());</span><br><span class="line">        mOut.writeInt32(BC_INCREFS_DONE);</span><br><span class="line">        mOut.writePointer((uintptr_t)refs);</span><br><span class="line">        mOut.writePointer((uintptr_t)obj);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_DECREFS:</span><br><span class="line">        refs &#x3D; (RefBase::weakref_type*)mIn.readPointer();</span><br><span class="line">        obj &#x3D; (BBinder*)mIn.readPointer();</span><br><span class="line">        &#x2F;&#x2F; NOTE: This assertion is not valid, because the object may no</span><br><span class="line">        &#x2F;&#x2F; longer exist (thus the (BBinder*)cast above resulting in a different</span><br><span class="line">        &#x2F;&#x2F; memory address).</span><br><span class="line">        &#x2F;&#x2F;ALOG_ASSERT(refs-&gt;refBase() &#x3D;&#x3D; obj,</span><br><span class="line">        &#x2F;&#x2F;           &quot;BR_DECREFS: object %p does not match cookie %p (expected %p)&quot;,</span><br><span class="line">        &#x2F;&#x2F;           refs, obj, refs-&gt;refBase());</span><br><span class="line">        mPendingWeakDerefs.push(refs);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_ATTEMPT_ACQUIRE:</span><br><span class="line">        refs &#x3D; (RefBase::weakref_type*)mIn.readPointer();</span><br><span class="line">        obj &#x3D; (BBinder*)mIn.readPointer();</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            const bool success &#x3D; refs-&gt;attemptIncStrong(mProcess.get());</span><br><span class="line">            ALOG_ASSERT(success &amp;&amp; refs-&gt;refBase() &#x3D;&#x3D; obj,</span><br><span class="line">                       &quot;BR_ATTEMPT_ACQUIRE: object %p does not match cookie %p (expected %p)&quot;,</span><br><span class="line">                       refs, obj, refs-&gt;refBase());</span><br><span class="line"></span><br><span class="line">            mOut.writeInt32(BC_ACQUIRE_RESULT);</span><br><span class="line">            mOut.writeInt32((int32_t)success);</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_TRANSACTION:</span><br><span class="line">        &#123;</span><br><span class="line">            binder_transaction_data tr;</span><br><span class="line">            result &#x3D; mIn.read(&amp;tr, sizeof(tr));</span><br><span class="line">            ALOG_ASSERT(result &#x3D;&#x3D; NO_ERROR,</span><br><span class="line">                &quot;Not enough command data for brTRANSACTION&quot;);</span><br><span class="line">            if (result !&#x3D; NO_ERROR) break;</span><br><span class="line"></span><br><span class="line">            Parcel buffer;</span><br><span class="line">            buffer.ipcSetDataReference(</span><br><span class="line">                reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                tr.data_size,</span><br><span class="line">                reinterpret_cast&lt;const binder_size_t*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                tr.offsets_size&#x2F;sizeof(binder_size_t), freeBuffer, this);</span><br><span class="line"></span><br><span class="line">            const pid_t origPid &#x3D; mCallingPid;</span><br><span class="line">            const uid_t origUid &#x3D; mCallingUid;</span><br><span class="line">            const int32_t origStrictModePolicy &#x3D; mStrictModePolicy;</span><br><span class="line">            const int32_t origTransactionBinderFlags &#x3D; mLastTransactionBinderFlags;</span><br><span class="line"></span><br><span class="line">            mCallingPid &#x3D; tr.sender_pid;</span><br><span class="line">            mCallingUid &#x3D; tr.sender_euid;</span><br><span class="line">            mLastTransactionBinderFlags &#x3D; tr.flags;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;ALOGI(&quot;&gt;&gt;&gt;&gt; TRANSACT from pid %d uid %d\n&quot;, mCallingPid, mCallingUid);</span><br><span class="line"></span><br><span class="line">            Parcel reply;</span><br><span class="line">            status_t error;</span><br><span class="line">            IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; &quot;BR_TRANSACTION thr &quot; &lt;&lt; (void*)pthread_self()</span><br><span class="line">                    &lt;&lt; &quot; &#x2F; obj &quot; &lt;&lt; tr.target.ptr &lt;&lt; &quot; &#x2F; code &quot;</span><br><span class="line">                    &lt;&lt; TypeCode(tr.code) &lt;&lt; &quot;: &quot; &lt;&lt; indent &lt;&lt; buffer</span><br><span class="line">                    &lt;&lt; dedent &lt;&lt; endl</span><br><span class="line">                    &lt;&lt; &quot;Data addr &#x3D; &quot;</span><br><span class="line">                    &lt;&lt; reinterpret_cast&lt;const uint8_t*&gt;(tr.data.ptr.buffer)</span><br><span class="line">                    &lt;&lt; &quot;, offsets addr&#x3D;&quot;</span><br><span class="line">                    &lt;&lt; reinterpret_cast&lt;const size_t*&gt;(tr.data.ptr.offsets) &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">            if (tr.target.ptr) &#123;</span><br><span class="line">                &#x2F;&#x2F; We only have a weak reference on the target object, so we must first try to</span><br><span class="line">                &#x2F;&#x2F; safely acquire a strong reference before doing anything else with it.</span><br><span class="line">                if (reinterpret_cast&lt;RefBase::weakref_type*&gt;(</span><br><span class="line">                        tr.target.ptr)-&gt;attemptIncStrong(this)) &#123;</span><br><span class="line">                    error &#x3D; reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer,</span><br><span class="line">                            &amp;reply, tr.flags);</span><br><span class="line">                    reinterpret_cast&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(this);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    error &#x3D; UNKNOWN_TRANSACTION;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                error &#x3D; the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;ALOGI(&quot;&lt;&lt;&lt;&lt; TRANSACT from pid %d restore pid %d uid %d\n&quot;,</span><br><span class="line">            &#x2F;&#x2F;     mCallingPid, origPid, origUid);</span><br><span class="line"></span><br><span class="line">            if ((tr.flags &amp; TF_ONE_WAY) &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                LOG_ONEWAY(&quot;Sending reply to %d!&quot;, mCallingPid);</span><br><span class="line">                if (error &lt; NO_ERROR) reply.setError(error);</span><br><span class="line">                sendReply(reply, 0);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                LOG_ONEWAY(&quot;NOT sending reply to %d!&quot;, mCallingPid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mCallingPid &#x3D; origPid;</span><br><span class="line">            mCallingUid &#x3D; origUid;</span><br><span class="line">            mStrictModePolicy &#x3D; origStrictModePolicy;</span><br><span class="line">            mLastTransactionBinderFlags &#x3D; origTransactionBinderFlags;</span><br><span class="line"></span><br><span class="line">            IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">                TextOutput::Bundle _b(alog);</span><br><span class="line">                alog &lt;&lt; &quot;BC_REPLY thr &quot; &lt;&lt; (void*)pthread_self() &lt;&lt; &quot; &#x2F; obj &quot;</span><br><span class="line">                    &lt;&lt; tr.target.ptr &lt;&lt; &quot;: &quot; &lt;&lt; indent &lt;&lt; reply &lt;&lt; dedent &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_DEAD_BINDER:</span><br><span class="line">        &#123;</span><br><span class="line">            BpBinder *proxy &#x3D; (BpBinder*)mIn.readPointer();</span><br><span class="line">            proxy-&gt;sendObituary();</span><br><span class="line">            mOut.writeInt32(BC_DEAD_BINDER_DONE);</span><br><span class="line">            mOut.writePointer((uintptr_t)proxy);</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">    case BR_CLEAR_DEATH_NOTIFICATION_DONE:</span><br><span class="line">        &#123;</span><br><span class="line">            BpBinder *proxy &#x3D; (BpBinder*)mIn.readPointer();</span><br><span class="line">            proxy-&gt;getWeakRefs()-&gt;decWeak(proxy);</span><br><span class="line">        &#125; break;</span><br><span class="line"></span><br><span class="line">    case BR_FINISHED:</span><br><span class="line">        result &#x3D; TIMED_OUT;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_NOOP:</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case BR_SPAWN_LOOPER:</span><br><span class="line">        mProcess-&gt;spawnPooledThread(false);</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        ALOGE(&quot;*** BAD COMMAND %d received from Binder driver\n&quot;, cmd);</span><br><span class="line">        result &#x3D; UNKNOWN_ERROR;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (result !&#x3D; NO_ERROR) &#123;</span><br><span class="line">        mLastError &#x3D; result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/guaong" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2020 Guaong<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>